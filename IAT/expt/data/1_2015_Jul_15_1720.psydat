ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
S'C:\\Users\\lsnoek1\\Dropbox\\ResMas_UvA\\Thesis\\Git\\IAT\\expt\\IAT-1.3.psyexp'
p7
sS'dataFileName'
p8
V/home/lukas/Dropbox/ResMas_UvA/Thesis/Git/IAT/expt/data/1_2015_Jul_15_1720
p9
sS'runtimeInfo'
p10
NsS'name'
p11
S'IAT-1.3'
p12
sS'dataNames'
p13
(lp14
S'key_resp_2.keys'
p15
aS'key_resp_2.corr'
p16
aS'key_resp_2.rt'
p17
aS'key_resp_7.keys'
p18
aS'key_resp_7.corr'
p19
aS'key_resp_7.rt'
p20
asS'autoLog'
p21
I01
sS'extraInfo'
p22
(dp23
Vsession
p24
V001
p25
sVparticipant
p26
V1
sS'frameRate'
p27
cnumpy.core.multiarray
scalar
p28
(cnumpy
dtype
p29
(S'f8'
I0
I1
tRp30
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x1f\xf0t\xf0e\xf5M@'
tRp31
sS'expName'
p32
g12
sS'date'
p33
V2015_Jul_15_1720
p34
sVorder
p35
V1
ssS'loopsUnfinished'
p36
(lp37
g1
(cpsychopy.data
TrialHandler
p38
g3
NtRp39
(dp40
S'origin'
p41
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.80.00), juli 10, 2015, at 12:23\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'IAT-1.3'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u'', u'order': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + u'data' + os.path.sep + '%s_%s' %(expInfo['participant'], expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath='C:\u005c\u005cUsers\u005c\u005clsnoek1\u005c\u005cDropbox\u005c\u005cResMas_UvA\u005c\u005cThesis\u005c\u005cGit\u005c\u005cIAT\u005c\u005cexpt\u005c\u005cIAT-1.3.psyexp',\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1680, 1050), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "SetupCode"\u000aSetupCodeClock = core.Clock()\u000a#Order is specified by experimenter at start of experiment via dialogue box\u000aorder=int(expInfo['order']) #convert to integer\u000a\u000a#Now counterbalance pro-stereotype vs anti-stereotype IAT blocks\u000a\u000a#Default is pro-stereotypical - "Congruent" first\u000atrainfiles=['cong_train.xlsx','incong_train.xlsx']\u000atestfiles=['cong_test.xlsx','incong_test.xlsx']\u000atrainlabelsL=['A = \u005cnJanos','A = \u005cnMatthias']\u000atrainlabelsR=['L = \u005cnMatthias','L = \u005cnJanos']\u000atestlabelsL=['A = \u005cnJanos of \u005cnPositief','A = \u005cnMatthias of \u005cnPositief']\u000atestlabelsR=['L = \u005cnMatthias of \u005cnNegatief','L = \u005cnJanos or \u005cnNegatief']\u000a\u000aif order==2:\u000a    #Anti-stereotypical - "Incongruent" first\u000a    trainfiles.reverse()\u000a    testfiles.reverse()\u000a    trainlabelsL.reverse()\u000a    trainlabelsR.reverse()\u000a    testlabelsL.reverse()\u000a    testlabelsR.reverse()\u000a\u000aif order is not (1 or 2):\u000a    print "UNRECOGNISED ORDER CODE - please use 1 or 2 only"\u000a\u000a\u000a#CREDITS\u000a\u000a'''\u000aDeveloped by Robin Scaife on the Leverhulme Trust "Bias and Blame" project 2014\u000aAdditional coding by Tom Stafford with thanks to Lily Fitzgibbon for advice\u000a'''\u000a\u000a# Initialize components for Routine "Instructions"\u000aInstructionsClock = core.Clock()\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text="Je zult woorden plaatjes te zien krijgen die je moet classificeren in categorieen door middel van de 'A' en 'L' toets.\u005cr\u005cn\u005cn\u005crProbeer zo snel mogelijk te kiezen en tegelijkertijd zo weinig mogelijk fouten te maken.\u005cr\u005cn\u005cn\u005crDruk op de spatiebalk om verder te gaan",    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "Keep_in_mind"\u000aKeep_in_mindClock = core.Clock()\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text="Onthoud:\u005cr\u005cn\u005cr\u005cn1) Labels aan de bovenkant van het scherm geven aan welke toets (A/L) hoort bij welke categorie.\u005cr\u005cn\u005cr\u005cn2) Elk woord en elke afbeelding heeft een correcte categorie.\u005cr\u005cn\u005cr\u005cn3) Houd je beide wijsvingers op de 'A' en 'L' toesten om snel antwoord te kunnen geven.\u005cr\u005cn\u005cr\u005cn4) De taak is nutteloos als je te langzaam antwoord geeft; kies daarom zo snel mogelijk\u005cr\u005cn\u005cr\u005cnDruk op de spatiebalk om te beginnen.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "Ready1"\u000aReady1Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text='Bekijk de categorieen bovenaan het scherm.\u005cr\u005cn\u005cr\u005cnPositioneer je wijsvingers op de toetsen (A/L).\u005cr\u005cn\u005cr\u005cnDruk op de spatiebalk om te beginnen.',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='A=Positief',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_5 = visual.TextStim(win=win, ori=0, name='text_5',\u000a    text='L=Negatief',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "Training1"\u000aTraining1Clock = core.Clock()\u000aPositive_label = visual.TextStim(win=win, ori=0, name='Positive_label',\u000a    text='A=Positief',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000aNegative_label = visual.TextStim(win=win, ori=0, name='Negative_label',\u000a    text='L=Negatief',    font='Arial',\u000a    pos=[0.8,0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-2.0)\u000a\u000a# Initialize components for Routine "Feedback1"\u000aFeedback1Clock = core.Clock()\u000amsg=""\u000a\u000atext_27 = visual.TextStim(win=win, ori=0, name='text_27',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_29 = visual.TextStim(win=win, ori=0, name='text_29',\u000a    text='A=Positief',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_30 = visual.TextStim(win=win, ori=0, name='text_30',\u000a    text='L=Negatief',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "Superloop_code"\u000aSuperloop_codeClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "Ready2"\u000aReady2Clock = core.Clock()\u000atext_6 = visual.TextStim(win=win, ori=0, name='text_6',\u000a    text='Bekijk de categorieen bovenaan het scherm.\u005cr\u005cn\u005cr\u005cnPositioneer je wijsvingers op de toetsen (A/L).\u005cr\u005cn\u005cr\u005cnDruk op de spatiebalk om te beginnen.',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_8 = visual.TextStim(win=win, ori=0, name='text_8',\u000a    text='default text',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "Training2"\u000aTraining2Clock = core.Clock()\u000atext_9 = visual.TextStim(win=win, ori=0, name='text_9',\u000a    text='default text',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_10 = visual.TextStim(win=win, ori=0, name='text_10',\u000a    text='default text',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-2.0)\u000a\u000a# Initialize components for Routine "Feedback2"\u000aFeedback2Clock = core.Clock()\u000amsg=""\u000a\u000atext_28 = visual.TextStim(win=win, ori=0, name='text_28',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_31 = visual.TextStim(win=win, ori=0, name='text_31',\u000a    text='default text',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_32 = visual.TextStim(win=win, ori=0, name='text_32',\u000a    text='default text',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "Ready3"\u000aReady3Clock = core.Clock()\u000atext_11 = visual.TextStim(win=win, ori=0, name='text_11',\u000a    text='Bekijk de categorieen bovenaan het scherm.\u005cr\u005cn\u005cr\u005cnPositioneer je wijsvingers op de toetsen (A/L).\u005cr\u005cn\u005cr\u005cnDruk op de spatiebalk om te beginnen.',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_12 = visual.TextStim(win=win, ori=0, name='text_12',\u000a    text='default text',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_13 = visual.TextStim(win=win, ori=0, name='text_13',\u000a    text='default text',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "Non_congruent"\u000aNon_congruentClock = core.Clock()\u000atext_14 = visual.TextStim(win=win, ori=0, name='text_14',\u000a    text='default text',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_15 = visual.TextStim(win=win, ori=0, name='text_15',\u000a    text='default text',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-2.0)\u000a\u000a# Initialize components for Routine "Feedback3"\u000aFeedback3Clock = core.Clock()\u000amsg=""\u000atext_33 = visual.TextStim(win=win, ori=0, name='text_33',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_34 = visual.TextStim(win=win, ori=0, name='text_34',\u000a    text='default text',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_35 = visual.TextStim(win=win, ori=0, name='text_35',\u000a    text='default text',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "End_Thanks"\u000aEnd_ThanksClock = core.Clock()\u000atext_26 = visual.TextStim(win=win, ori=0, name='text_26',\u000a    text='De taak is nu afgelopen!',    font='Arial',\u000a    pos=[0, 0], height=0.2, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "SetupCode"-------\u000at = 0\u000aSetupCodeClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aSetupCodeComponents = []\u000afor thisComponent in SetupCodeComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "SetupCode"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = SetupCodeClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in SetupCodeComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "SetupCode"-------\u000afor thisComponent in SetupCodeComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "SetupCode" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#------Prepare to start Routine "Instructions"-------\u000at = 0\u000aInstructionsClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aInstructionsComponents = []\u000aInstructionsComponents.append(text_2)\u000aInstructionsComponents.append(key_resp_3)\u000afor thisComponent in InstructionsComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Instructions"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = InstructionsClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_2* updates\u000a    if t >= 0.0 and text_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_2.tStart = t  # underestimates by a little under one frame\u000a        text_2.frameNStart = frameN  # exact frame index\u000a        text_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_3* updates\u000a    if t >= 0.0 and key_resp_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_3.frameNStart = frameN  # exact frame index\u000a        key_resp_3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in InstructionsComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Instructions"-------\u000afor thisComponent in InstructionsComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# the Routine "Instructions" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#------Prepare to start Routine "Keep_in_mind"-------\u000at = 0\u000aKeep_in_mindClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aKeep_in_mindComponents = []\u000aKeep_in_mindComponents.append(text_3)\u000aKeep_in_mindComponents.append(key_resp_4)\u000afor thisComponent in Keep_in_mindComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Keep_in_mind"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Keep_in_mindClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_3* updates\u000a    if t >= 0.0 and text_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_3.tStart = t  # underestimates by a little under one frame\u000a        text_3.frameNStart = frameN  # exact frame index\u000a        text_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_4* updates\u000a    if t >= 0.0 and key_resp_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_4.frameNStart = frameN  # exact frame index\u000a        key_resp_4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Keep_in_mindComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Keep_in_mind"-------\u000afor thisComponent in Keep_in_mindComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# the Routine "Keep_in_mind" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#------Prepare to start Routine "Ready1"-------\u000at = 0\u000aReady1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aReady1Components = []\u000aReady1Components.append(text)\u000aReady1Components.append(key_resp_5)\u000aReady1Components.append(text_4)\u000aReady1Components.append(text_5)\u000afor thisComponent in Ready1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Ready1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Ready1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text* updates\u000a    if t >= 0.0 and text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text.tStart = t  # underestimates by a little under one frame\u000a        text.frameNStart = frameN  # exact frame index\u000a        text.setAutoDraw(True)\u000a    \u000a    # *key_resp_5* updates\u000a    if t >= 0.0 and key_resp_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_5.frameNStart = frameN  # exact frame index\u000a        key_resp_5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # *text_4* updates\u000a    if t >= 0.0 and text_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_4.tStart = t  # underestimates by a little under one frame\u000a        text_4.frameNStart = frameN  # exact frame index\u000a        text_4.setAutoDraw(True)\u000a    \u000a    # *text_5* updates\u000a    if t >= 0.0 and text_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_5.tStart = t  # underestimates by a little under one frame\u000a        text_5.frameNStart = frameN  # exact frame index\u000a        text_5.setAutoDraw(True)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Ready1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Ready1"-------\u000afor thisComponent in Ready1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# the Routine "Ready1" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aTrain_pos_neg = data.TrialHandler(nReps=1, method='random', \u000a    extraInfo=expInfo, originPath='C:\u005c\u005cUsers\u005c\u005clsnoek1\u005c\u005cDropbox\u005c\u005cResMas_UvA\u005c\u005cThesis\u005c\u005cGit\u005c\u005cIAT\u005c\u005cexpt\u005c\u005cIAT-1.3.psyexp',\u000a    trialList=data.importConditions('pos_neg_train.xlsx'),\u000a    seed=None, name='Train_pos_neg')\u000athisExp.addLoop(Train_pos_neg)  # add the loop to the experiment\u000athisTrain_pos_neg = Train_pos_neg.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTrain_pos_neg.rgb)\u000aif thisTrain_pos_neg != None:\u000a    for paramName in thisTrain_pos_neg.keys():\u000a        exec(paramName + '= thisTrain_pos_neg.' + paramName)\u000a\u000afor thisTrain_pos_neg in Train_pos_neg:\u000a    currentLoop = Train_pos_neg\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTrain_pos_neg.rgb)\u000a    if thisTrain_pos_neg != None:\u000a        for paramName in thisTrain_pos_neg.keys():\u000a            exec(paramName + '= thisTrain_pos_neg.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Training1"-------\u000a    t = 0\u000a    Training1Clock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    image_3.setImage(os.path.join('stimuli',StimuliImages))\u000a    key_resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    Training1Components = []\u000a    Training1Components.append(Positive_label)\u000a    Training1Components.append(Negative_label)\u000a    Training1Components.append(image_3)\u000a    Training1Components.append(key_resp_2)\u000a    for thisComponent in Training1Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Training1"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Training1Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *Positive_label* updates\u000a        if t >= 0.0 and Positive_label.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Positive_label.tStart = t  # underestimates by a little under one frame\u000a            Positive_label.frameNStart = frameN  # exact frame index\u000a            Positive_label.setAutoDraw(True)\u000a        \u000a        # *Negative_label* updates\u000a        if t >= 0.0 and Negative_label.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Negative_label.tStart = t  # underestimates by a little under one frame\u000a            Negative_label.frameNStart = frameN  # exact frame index\u000a            Negative_label.setAutoDraw(True)\u000a        \u000a        # *image_3* updates\u000a        if t >= 0.0 and image_3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            image_3.tStart = t  # underestimates by a little under one frame\u000a            image_3.frameNStart = frameN  # exact frame index\u000a            image_3.setAutoDraw(True)\u000a        \u000a        # *key_resp_2* updates\u000a        if t >= 0.0 and key_resp_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_2.tStart = t  # underestimates by a little under one frame\u000a            key_resp_2.frameNStart = frameN  # exact frame index\u000a            key_resp_2.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['a', 'l'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_2.rt = key_resp_2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (key_resp_2.keys == str(CorrAns1)) or (key_resp_2.keys == CorrAns1):\u000a                    key_resp_2.corr = 1\u000a                else:\u000a                    key_resp_2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Training1Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Training1"-------\u000a    for thisComponent in Training1Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_2.keys in ['', [], None]:  # No response was made\u000a       key_resp_2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(CorrAns1).lower() == 'none': key_resp_2.corr = 1  # correct non-response\u000a       else: key_resp_2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for Train_pos_neg (TrialHandler)\u000a    Train_pos_neg.addData('key_resp_2.keys',key_resp_2.keys)\u000a    Train_pos_neg.addData('key_resp_2.corr', key_resp_2.corr)\u000a    if key_resp_2.keys != None:  # we had a response\u000a        Train_pos_neg.addData('key_resp_2.rt', key_resp_2.rt)\u000a    # the Routine "Training1" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    #------Prepare to start Routine "Feedback1"-------\u000a    t = 0\u000a    Feedback1Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if key_resp_2.corr==0:\u000a        msg="Fout!"\u000a    elif key_resp_2.corr==1:\u000a        msg=""\u000a    \u000a    text_27.setText(msg)\u000a    # keep track of which components have finished\u000a    Feedback1Components = []\u000a    Feedback1Components.append(text_27)\u000a    Feedback1Components.append(text_29)\u000a    Feedback1Components.append(text_30)\u000a    for thisComponent in Feedback1Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Feedback1"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = Feedback1Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *text_27* updates\u000a        if t >= 0.0 and text_27.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_27.tStart = t  # underestimates by a little under one frame\u000a            text_27.frameNStart = frameN  # exact frame index\u000a            text_27.setAutoDraw(True)\u000a        if text_27.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_27.setAutoDraw(False)\u000a        \u000a        # *text_29* updates\u000a        if t >= 0.0 and text_29.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_29.tStart = t  # underestimates by a little under one frame\u000a            text_29.frameNStart = frameN  # exact frame index\u000a            text_29.setAutoDraw(True)\u000a        if text_29.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_29.setAutoDraw(False)\u000a        \u000a        # *text_30* updates\u000a        if t >= 0.0 and text_30.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_30.tStart = t  # underestimates by a little under one frame\u000a            text_30.frameNStart = frameN  # exact frame index\u000a            text_30.setAutoDraw(True)\u000a        if text_30.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_30.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Feedback1Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Feedback1"-------\u000a    for thisComponent in Feedback1Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'Train_pos_neg'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000asuperloop = data.TrialHandler(nReps=2, method='sequential', \u000a    extraInfo=expInfo, originPath='C:\u005c\u005cUsers\u005c\u005clsnoek1\u005c\u005cDropbox\u005c\u005cResMas_UvA\u005c\u005cThesis\u005c\u005cGit\u005c\u005cIAT\u005c\u005cexpt\u005c\u005cIAT-1.3.psyexp',\u000a    trialList=[None],\u000a    seed=None, name='superloop')\u000athisExp.addLoop(superloop)  # add the loop to the experiment\u000athisSuperloop = superloop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisSuperloop.rgb)\u000aif thisSuperloop != None:\u000a    for paramName in thisSuperloop.keys():\u000a        exec(paramName + '= thisSuperloop.' + paramName)\u000a\u000afor thisSuperloop in superloop:\u000a    currentLoop = superloop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisSuperloop.rgb)\u000a    if thisSuperloop != None:\u000a        for paramName in thisSuperloop.keys():\u000a            exec(paramName + '= thisSuperloop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Superloop_code"-------\u000a    t = 0\u000a    Superloop_codeClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    #Set stimuli files and labels according to this is the 1st or 2nd time we are here\u000a    testblockfile=testfiles[superloop.thisRepN]\u000a    trainblockfile=trainfiles[superloop.thisRepN]\u000a    trainlabelL=trainlabelsL[superloop.thisRepN]\u000a    trainlabelR=trainlabelsR[superloop.thisRepN]\u000a    testlabelL=testlabelsL[superloop.thisRepN]\u000a    testlabelR=testlabelsR[superloop.thisRepN]\u000a    \u000a    # keep track of which components have finished\u000a    Superloop_codeComponents = []\u000a    for thisComponent in Superloop_codeComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Superloop_code"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Superloop_codeClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Superloop_codeComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Superloop_code"-------\u000a    for thisComponent in Superloop_codeComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Superloop_code" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    #------Prepare to start Routine "Ready2"-------\u000a    t = 0\u000a    Ready2Clock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_6.status = NOT_STARTED\u000a    text_7.setText(trainlabelL)\u000a    text_8.setText(trainlabelR)\u000a    # keep track of which components have finished\u000a    Ready2Components = []\u000a    Ready2Components.append(text_6)\u000a    Ready2Components.append(key_resp_6)\u000a    Ready2Components.append(text_7)\u000a    Ready2Components.append(text_8)\u000a    for thisComponent in Ready2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Ready2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Ready2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_6* updates\u000a        if t >= 0.0 and text_6.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_6.tStart = t  # underestimates by a little under one frame\u000a            text_6.frameNStart = frameN  # exact frame index\u000a            text_6.setAutoDraw(True)\u000a        \u000a        # *key_resp_6* updates\u000a        if t >= 0.0 and key_resp_6.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_6.tStart = t  # underestimates by a little under one frame\u000a            key_resp_6.frameNStart = frameN  # exact frame index\u000a            key_resp_6.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_6.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *text_7* updates\u000a        if t >= 0.0 and text_7.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_7.tStart = t  # underestimates by a little under one frame\u000a            text_7.frameNStart = frameN  # exact frame index\u000a            text_7.setAutoDraw(True)\u000a        \u000a        # *text_8* updates\u000a        if t >= 0.0 and text_8.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_8.tStart = t  # underestimates by a little under one frame\u000a            text_8.frameNStart = frameN  # exact frame index\u000a            text_8.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Ready2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Ready2"-------\u000a    for thisComponent in Ready2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # the Routine "Ready2" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Train_target_stimuli = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath='C:\u005c\u005cUsers\u005c\u005clsnoek1\u005c\u005cDropbox\u005c\u005cResMas_UvA\u005c\u005cThesis\u005c\u005cGit\u005c\u005cIAT\u005c\u005cexpt\u005c\u005cIAT-1.3.psyexp',\u000a        trialList=data.importConditions(trainblockfile),\u000a        seed=None, name='Train_target_stimuli')\u000a    thisExp.addLoop(Train_target_stimuli)  # add the loop to the experiment\u000a    thisTrain_target_stimulu = Train_target_stimuli.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrain_target_stimulu.rgb)\u000a    if thisTrain_target_stimulu != None:\u000a        for paramName in thisTrain_target_stimulu.keys():\u000a            exec(paramName + '= thisTrain_target_stimulu.' + paramName)\u000a    \u000a    for thisTrain_target_stimulu in Train_target_stimuli:\u000a        currentLoop = Train_target_stimuli\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrain_target_stimulu.rgb)\u000a        if thisTrain_target_stimulu != None:\u000a            for paramName in thisTrain_target_stimulu.keys():\u000a                exec(paramName + '= thisTrain_target_stimulu.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Training2"-------\u000a        t = 0\u000a        Training2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        text_9.setText(trainlabelL)\u000a        text_10.setText(trainlabelR)\u000a        image.setImage(os.path.join('stimuli',TrialImages))\u000a        key_resp_7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_7.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        Training2Components = []\u000a        Training2Components.append(text_9)\u000a        Training2Components.append(text_10)\u000a        Training2Components.append(image)\u000a        Training2Components.append(key_resp_7)\u000a        for thisComponent in Training2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Training2"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = Training2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text_9* updates\u000a            if t >= 0.0 and text_9.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_9.tStart = t  # underestimates by a little under one frame\u000a                text_9.frameNStart = frameN  # exact frame index\u000a                text_9.setAutoDraw(True)\u000a            \u000a            # *text_10* updates\u000a            if t >= 0.0 and text_10.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_10.tStart = t  # underestimates by a little under one frame\u000a                text_10.frameNStart = frameN  # exact frame index\u000a                text_10.setAutoDraw(True)\u000a            \u000a            # *image* updates\u000a            if t >= 0.0 and image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                image.tStart = t  # underestimates by a little under one frame\u000a                image.frameNStart = frameN  # exact frame index\u000a                image.setAutoDraw(True)\u000a            \u000a            # *key_resp_7* updates\u000a            if t >= 0.0 and key_resp_7.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_7.tStart = t  # underestimates by a little under one frame\u000a                key_resp_7.frameNStart = frameN  # exact frame index\u000a                key_resp_7.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_7.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if key_resp_7.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['a', 'l'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_7.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_7.rt = key_resp_7.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_7.keys == str(CorrAns)) or (key_resp_7.keys == CorrAns):\u000a                        key_resp_7.corr = 1\u000a                    else:\u000a                        key_resp_7.corr = 0\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in Training2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Training2"-------\u000a        for thisComponent in Training2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_7.keys in ['', [], None]:  # No response was made\u000a           key_resp_7.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrAns).lower() == 'none': key_resp_7.corr = 1  # correct non-response\u000a           else: key_resp_7.corr = 0  # failed to respond (incorrectly)\u000a        # store data for Train_target_stimuli (TrialHandler)\u000a        Train_target_stimuli.addData('key_resp_7.keys',key_resp_7.keys)\u000a        Train_target_stimuli.addData('key_resp_7.corr', key_resp_7.corr)\u000a        if key_resp_7.keys != None:  # we had a response\u000a            Train_target_stimuli.addData('key_resp_7.rt', key_resp_7.rt)\u000a        # the Routine "Training2" was not non-slip safe, so reset the non-slip timer\u000a        routineTimer.reset()\u000a        \u000a        #------Prepare to start Routine "Feedback2"-------\u000a        t = 0\u000a        Feedback2Clock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(1.000000)\u000a        # update component parameters for each repeat\u000a        if key_resp_7.corr==0:\u000a            msg="Fout!"\u000a        elif key_resp_7.corr==1:\u000a            msg=""\u000a        \u000a        text_28.setText(msg)\u000a        text_31.setText(trainlabelL)\u000a        text_32.setText(trainlabelR)\u000a        # keep track of which components have finished\u000a        Feedback2Components = []\u000a        Feedback2Components.append(text_28)\u000a        Feedback2Components.append(text_31)\u000a        Feedback2Components.append(text_32)\u000a        for thisComponent in Feedback2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback2"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = Feedback2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *text_28* updates\u000a            if t >= 0.0 and text_28.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_28.tStart = t  # underestimates by a little under one frame\u000a                text_28.frameNStart = frameN  # exact frame index\u000a                text_28.setAutoDraw(True)\u000a            if text_28.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_28.setAutoDraw(False)\u000a            \u000a            # *text_31* updates\u000a            if t >= 0.0 and text_31.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_31.tStart = t  # underestimates by a little under one frame\u000a                text_31.frameNStart = frameN  # exact frame index\u000a                text_31.setAutoDraw(True)\u000a            if text_31.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_31.setAutoDraw(False)\u000a            \u000a            # *text_32* updates\u000a            if t >= 0.0 and text_32.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_32.tStart = t  # underestimates by a little under one frame\u000a                text_32.frameNStart = frameN  # exact frame index\u000a                text_32.setAutoDraw(True)\u000a            if text_32.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_32.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in Feedback2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback2"-------\u000a        for thisComponent in Feedback2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Train_target_stimuli'\u000a    \u000a    \u000a    #------Prepare to start Routine "Ready3"-------\u000a    t = 0\u000a    Ready3Clock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_8.status = NOT_STARTED\u000a    text_12.setText(testlabelL)\u000a    text_13.setText(testlabelR)\u000a    # keep track of which components have finished\u000a    Ready3Components = []\u000a    Ready3Components.append(text_11)\u000a    Ready3Components.append(key_resp_8)\u000a    Ready3Components.append(text_12)\u000a    Ready3Components.append(text_13)\u000a    for thisComponent in Ready3Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Ready3"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Ready3Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_11* updates\u000a        if t >= 0.0 and text_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_11.tStart = t  # underestimates by a little under one frame\u000a            text_11.frameNStart = frameN  # exact frame index\u000a            text_11.setAutoDraw(True)\u000a        \u000a        # *key_resp_8* updates\u000a        if t >= 0.0 and key_resp_8.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_8.tStart = t  # underestimates by a little under one frame\u000a            key_resp_8.frameNStart = frameN  # exact frame index\u000a            key_resp_8.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_8.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *text_12* updates\u000a        if t >= 0.0 and text_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_12.tStart = t  # underestimates by a little under one frame\u000a            text_12.frameNStart = frameN  # exact frame index\u000a            text_12.setAutoDraw(True)\u000a        \u000a        # *text_13* updates\u000a        if t >= 0.0 and text_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_13.tStart = t  # underestimates by a little under one frame\u000a            text_13.frameNStart = frameN  # exact frame index\u000a            text_13.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Ready3Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Ready3"-------\u000a    for thisComponent in Ready3Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # the Routine "Ready3" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Test_associations = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath='C:\u005c\u005cUsers\u005c\u005clsnoek1\u005c\u005cDropbox\u005c\u005cResMas_UvA\u005c\u005cThesis\u005c\u005cGit\u005c\u005cIAT\u005c\u005cexpt\u005c\u005cIAT-1.3.psyexp',\u000a        trialList=data.importConditions(testblockfile),\u000a        seed=None, name='Test_associations')\u000a    thisExp.addLoop(Test_associations)  # add the loop to the experiment\u000a    thisTest_association = Test_associations.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTest_association.rgb)\u000a    if thisTest_association != None:\u000a        for paramName in thisTest_association.keys():\u000a            exec(paramName + '= thisTest_association.' + paramName)\u000a    \u000a    for thisTest_association in Test_associations:\u000a        currentLoop = Test_associations\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTest_association.rgb)\u000a        if thisTest_association != None:\u000a            for paramName in thisTest_association.keys():\u000a                exec(paramName + '= thisTest_association.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Non_congruent"-------\u000a        t = 0\u000a        Non_congruentClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        text_14.setText(testlabelL)\u000a        text_15.setText(testlabelR)\u000a        image_2.setImage(os.path.join('stimuli',TrialImages))\u000a        key_resp_9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_9.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        Non_congruentComponents = []\u000a        Non_congruentComponents.append(text_14)\u000a        Non_congruentComponents.append(text_15)\u000a        Non_congruentComponents.append(image_2)\u000a        Non_congruentComponents.append(key_resp_9)\u000a        for thisComponent in Non_congruentComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Non_congruent"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = Non_congruentClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text_14* updates\u000a            if t >= 0.0 and text_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_14.tStart = t  # underestimates by a little under one frame\u000a                text_14.frameNStart = frameN  # exact frame index\u000a                text_14.setAutoDraw(True)\u000a            \u000a            # *text_15* updates\u000a            if t >= 0.0 and text_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_15.tStart = t  # underestimates by a little under one frame\u000a                text_15.frameNStart = frameN  # exact frame index\u000a                text_15.setAutoDraw(True)\u000a            \u000a            # *image_2* updates\u000a            if t >= 0.0 and image_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                image_2.tStart = t  # underestimates by a little under one frame\u000a                image_2.frameNStart = frameN  # exact frame index\u000a                image_2.setAutoDraw(True)\u000a            \u000a            # *key_resp_9* updates\u000a            if t >= 0.0 and key_resp_9.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_9.tStart = t  # underestimates by a little under one frame\u000a                key_resp_9.frameNStart = frameN  # exact frame index\u000a                key_resp_9.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_9.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if key_resp_9.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['a', 'l'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_9.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_9.rt = key_resp_9.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_9.keys == str(CorrAns)) or (key_resp_9.keys == CorrAns):\u000a                        key_resp_9.corr = 1\u000a                    else:\u000a                        key_resp_9.corr = 0\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in Non_congruentComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Non_congruent"-------\u000a        for thisComponent in Non_congruentComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_9.keys in ['', [], None]:  # No response was made\u000a           key_resp_9.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrAns).lower() == 'none': key_resp_9.corr = 1  # correct non-response\u000a           else: key_resp_9.corr = 0  # failed to respond (incorrectly)\u000a        # store data for Test_associations (TrialHandler)\u000a        Test_associations.addData('key_resp_9.keys',key_resp_9.keys)\u000a        Test_associations.addData('key_resp_9.corr', key_resp_9.corr)\u000a        if key_resp_9.keys != None:  # we had a response\u000a            Test_associations.addData('key_resp_9.rt', key_resp_9.rt)\u000a        # the Routine "Non_congruent" was not non-slip safe, so reset the non-slip timer\u000a        routineTimer.reset()\u000a        \u000a        #------Prepare to start Routine "Feedback3"-------\u000a        t = 0\u000a        Feedback3Clock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(1.000000)\u000a        # update component parameters for each repeat\u000a        if key_resp_9.corr==0:\u000a            msg="Fout!"\u000a        elif key_resp_9.corr==1:\u000a            msg=""\u000a        \u000a        text_33.setText(msg)\u000a        text_34.setText(testlabelL)\u000a        text_35.setText(testlabelR)\u000a        # keep track of which components have finished\u000a        Feedback3Components = []\u000a        Feedback3Components.append(text_33)\u000a        Feedback3Components.append(text_34)\u000a        Feedback3Components.append(text_35)\u000a        for thisComponent in Feedback3Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback3"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = Feedback3Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *text_33* updates\u000a            if t >= 0.0 and text_33.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_33.tStart = t  # underestimates by a little under one frame\u000a                text_33.frameNStart = frameN  # exact frame index\u000a                text_33.setAutoDraw(True)\u000a            if text_33.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_33.setAutoDraw(False)\u000a            \u000a            # *text_34* updates\u000a            if t >= 0.0 and text_34.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_34.tStart = t  # underestimates by a little under one frame\u000a                text_34.frameNStart = frameN  # exact frame index\u000a                text_34.setAutoDraw(True)\u000a            if text_34.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_34.setAutoDraw(False)\u000a            \u000a            # *text_35* updates\u000a            if t >= 0.0 and text_35.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_35.tStart = t  # underestimates by a little under one frame\u000a                text_35.frameNStart = frameN  # exact frame index\u000a                text_35.setAutoDraw(True)\u000a            if text_35.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_35.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in Feedback3Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback3"-------\u000a        for thisComponent in Feedback3Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Test_associations'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 2 repeats of 'superloop'\u000a\u000a\u000a#------Prepare to start Routine "End_Thanks"-------\u000at = 0\u000aEnd_ThanksClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a# keep track of which components have finished\u000aEnd_ThanksComponents = []\u000aEnd_ThanksComponents.append(text_26)\u000afor thisComponent in End_ThanksComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "End_Thanks"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = End_ThanksClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_26* updates\u000a    if t >= 0.0 and text_26.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_26.tStart = t  # underestimates by a little under one frame\u000a        text_26.frameNStart = frameN  # exact frame index\u000a        text_26.setAutoDraw(True)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in End_ThanksComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "End_Thanks"-------\u000afor thisComponent in End_ThanksComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# the Routine "End_Thanks" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000awin.close()\u000acore.quit()\u000a
p42
sS'thisTrial'
p43
NsS'_exp'
p44
I140639271777552
sg11
S'superloop'
p45
sg6
S'/home/lukas/Dropbox/ResMas_UvA/Thesis/Git/IAT/expt/IAT_adaptedto_DA.py'
p46
sS'thisRepN'
p47
I0
sg21
I01
sg22
g23
sS'data'
p48
g1
(cpsychopy.data
DataHandler
p49
c__builtin__
dict
p50
(dp51
S'ran'
p52
cnumpy.ma.core
_mareconstruct
p53
(cnumpy.ma.core
MaskedArray
p54
cnumpy
ndarray
p55
(I0
tp56
S'b'
tRp57
(I1
(I1
I2
tg29
(S'f4'
I0
I1
tRp58
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x00\x00'
S'\x00\x00'
NtbsS'order'
p59
g53
(g54
g55
g56
S'b'
tRp60
(I1
(I1
I2
tg58
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x01'
NtbstRp61
(dp62
S'isNumeric'
p63
(dp64
g52
I01
sg59
I01
ssS'trials'
p65
g39
sS'dataTypes'
p66
(lp67
g52
ag59
asS'dataShape'
p68
(lp69
I1
aI2
asbsS'method'
p70
S'sequential'
p71
sS'sequenceIndices'
p72
cnumpy.core.multiarray
_reconstruct
p73
(g55
(I0
tS'b'
tRp74
(I1
(I1
I2
tg29
(S'i8'
I0
I1
tRp75
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
tbsS'finished'
p76
I00
sS'nReps'
p77
I2
sS'nRemaining'
p78
I1
sS'trialList'
p79
(lp80
NasS'seed'
p81
NsS'thisIndex'
p82
g28
(g75
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp83
sS'thisN'
p84
I0
sS'thisTrialN'
p85
I0
sS'nTotal'
p86
I2
sS'_warnUseOfNext'
p87
I01
sbasS'saveWideText'
p88
I01
sS'thisEntry'
p89
(dp90
sS'version'
p91
S''
sS'_paramNamesSoFar'
p92
(lp93
VStimuliImages
p94
aVCorrAns1
p95
aVTrialImages
p96
aVCorrAns
p97
asS'entries'
p98
(lp99
(dp100
g17
F1.3587770462036133
sg32
g12
sg26
V1
sS'Train_pos_neg.thisTrialN'
p101
I0
sg16
I1
sg27
g31
sg94
VNasty.jpg
p102
sg15
S'l'
sg95
Vl
sS'Train_pos_neg.thisN'
p103
I0
sg24
g25
sg33
g34
sS'Train_pos_neg.thisIndex'
p104
g28
(g75
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp105
sg35
V1
sS'Train_pos_neg.thisRepN'
p106
I0
sa(dp107
g17
F1.217710018157959
sg32
g12
sg26
V1
sS'Train_pos_neg.thisTrialN'
p108
I1
sg16
I1
sg27
g31
sg94
VAgony.jpg
p109
sg15
S'l'
sg95
Vl
sS'Train_pos_neg.thisN'
p110
I1
sg24
g25
sg33
g34
sS'Train_pos_neg.thisIndex'
p111
g28
(g75
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp112
sg35
V1
sS'Train_pos_neg.thisRepN'
p113
I0
sa(dp114
g17
F0.7494511604309082
sg32
g12
sg26
V1
sS'Train_pos_neg.thisTrialN'
p115
I2
sg16
I1
sg27
g31
sg94
VBad.jpg
p116
sg15
S'l'
sg95
Vl
sS'Train_pos_neg.thisN'
p117
I2
sg24
g25
sg33
g34
sS'Train_pos_neg.thisIndex'
p118
g28
(g75
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp119
sg35
V1
sS'Train_pos_neg.thisRepN'
p120
I0
sa(dp121
g17
F0.58234596252441406
sg32
g12
sg26
V1
sS'Train_pos_neg.thisTrialN'
p122
I3
sg16
I1
sg27
g31
sg94
VLove.jpg
p123
sg15
S'a'
sg95
Va
sS'Train_pos_neg.thisN'
p124
I3
sg24
g25
sg33
g34
sS'Train_pos_neg.thisIndex'
p125
g28
(g75
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp126
sg35
V1
sS'Train_pos_neg.thisRepN'
p127
I0
sa(dp128
g17
F0.59958505630493164
sg32
g12
sg26
V1
sS'Train_pos_neg.thisTrialN'
p129
I4
sg16
I1
sg27
g31
sg94
VHappy.jpg
p130
sg15
S'a'
sg95
Va
sS'Train_pos_neg.thisN'
p131
I4
sg24
g25
sg33
g34
sS'Train_pos_neg.thisIndex'
p132
g28
(g75
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp133
sg35
V1
sS'Train_pos_neg.thisRepN'
p134
I0
sa(dp135
g17
F1.0505061149597168
sg32
g12
sg26
V1
sS'Train_pos_neg.thisTrialN'
p136
I5
sg16
I1
sg27
g31
sg94
VJoy.jpg
p137
sg15
S'a'
sg95
Va
sS'Train_pos_neg.thisN'
p138
I5
sg24
g25
sg33
g34
sS'Train_pos_neg.thisIndex'
p139
g28
(g75
S'\x08\x00\x00\x00\x00\x00\x00\x00'
tRp140
sg35
V1
sS'Train_pos_neg.thisRepN'
p141
I0
sa(dp142
g17
F0.48253893852233887
sg32
g12
sg26
V1
sS'Train_pos_neg.thisTrialN'
p143
I6
sg16
I1
sg27
g31
sg94
VHurt.jpg
p144
sg15
S'l'
sg95
Vl
sS'Train_pos_neg.thisN'
p145
I6
sg24
g25
sg33
g34
sS'Train_pos_neg.thisIndex'
p146
g28
(g75
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp147
sg35
V1
sS'Train_pos_neg.thisRepN'
p148
I0
sa(dp149
g17
F0.86897516250610352
sg32
g12
sg26
V1
sS'Train_pos_neg.thisTrialN'
p150
I7
sg16
I1
sg27
g31
sg94
VPleasure.jpg
p151
sg15
S'a'
sg95
Va
sS'Train_pos_neg.thisN'
p152
I7
sg24
g25
sg33
g34
sS'Train_pos_neg.thisIndex'
p153
g28
(g75
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp154
sg35
V1
sS'Train_pos_neg.thisRepN'
p155
I0
sa(dp156
g17
F0.74980807304382324
sg32
g12
sg26
V1
sS'Train_pos_neg.thisTrialN'
p157
I8
sg16
I1
sg27
g31
sg94
VGood.jpg
p158
sg15
S'a'
sg95
Va
sS'Train_pos_neg.thisN'
p159
I8
sg24
g25
sg33
g34
sS'Train_pos_neg.thisIndex'
p160
g28
(g75
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp161
sg35
V1
sS'Train_pos_neg.thisRepN'
p162
I0
sa(dp163
g17
F0.89986014366149902
sg32
g12
sg26
V1
sS'Train_pos_neg.thisTrialN'
p164
I9
sg16
I1
sg27
g31
sg94
VEvil.jpg
p165
sg15
S'l'
sg95
Vl
sS'Train_pos_neg.thisN'
p166
I9
sg24
g25
sg33
g34
sS'Train_pos_neg.thisIndex'
p167
g28
(g75
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp168
sg35
V1
sS'Train_pos_neg.thisRepN'
p169
I0
sa(dp170
S'superloop.thisRepN'
p171
I0
sS'Train_target_stimuli.thisTrialN'
p172
I0
sg32
g12
sg26
V1
sg20
F1.0708940029144287
sg27
g31
sS'superloop.thisTrialN'
p173
I0
sS'superloop.thisTrial'
p174
NsS'superloop.thisN'
p175
I0
sg96
Vchar_matthias.jpg
p176
sg24
g25
sS'Train_target_stimuli.thisRepN'
p177
I0
sg18
S'l'
sS'Train_target_stimuli.thisIndex'
p178
g28
(g75
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp179
sg33
g34
sS'Train_target_stimuli.thisN'
p180
I0
sg97
Vl
sg35
V1
sS'superloop.thisIndex'
p181
g83
sg19
I1
sa(dp182
S'superloop.thisRepN'
p183
I0
sS'Train_target_stimuli.thisTrialN'
p184
I1
sg32
g12
sg26
V1
sg20
F0.58110380172729492
sg27
g31
sS'superloop.thisTrialN'
p185
I0
sS'superloop.thisTrial'
p186
NsS'superloop.thisN'
p187
I0
sg96
g176
sg24
g25
sS'Train_target_stimuli.thisRepN'
p188
I0
sg18
S'l'
sS'Train_target_stimuli.thisIndex'
p189
g28
(g75
S'\x08\x00\x00\x00\x00\x00\x00\x00'
tRp190
sg33
g34
sS'Train_target_stimuli.thisN'
p191
I1
sg97
Vl
sg35
V1
sS'superloop.thisIndex'
p192
g83
sg19
I1
sa(dp193
S'superloop.thisRepN'
p194
I0
sS'Train_target_stimuli.thisTrialN'
p195
I2
sg32
g12
sg26
V1
sg20
F0.69806694984436035
sg27
g31
sS'superloop.thisTrialN'
p196
I0
sS'superloop.thisTrial'
p197
NsS'superloop.thisN'
p198
I0
sg96
Vchar_janos.jpg
p199
sg24
g25
sS'Train_target_stimuli.thisRepN'
p200
I0
sg18
S'a'
sS'Train_target_stimuli.thisIndex'
p201
g28
(g75
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp202
sg33
g34
sS'Train_target_stimuli.thisN'
p203
I2
sg97
Va
sg35
V1
sS'superloop.thisIndex'
p204
g83
sg19
I1
sa(dp205
S'superloop.thisRepN'
p206
I0
sS'Train_target_stimuli.thisTrialN'
p207
I3
sg32
g12
sg26
V1
sg20
F1.1659548282623291
sg27
g31
sS'superloop.thisTrialN'
p208
I0
sS'superloop.thisTrial'
p209
NsS'superloop.thisN'
p210
I0
sg96
g199
sg24
g25
sS'Train_target_stimuli.thisRepN'
p211
I0
sg18
S'a'
sS'Train_target_stimuli.thisIndex'
p212
g28
(g75
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp213
sg33
g34
sS'Train_target_stimuli.thisN'
p214
I3
sg97
Va
sg35
V1
sS'superloop.thisIndex'
p215
g83
sg19
I1
sa(dp216
S'superloop.thisRepN'
p217
I0
sS'Train_target_stimuli.thisTrialN'
p218
I4
sg32
g12
sg26
V1
sg20
F0.73161005973815918
sg27
g31
sS'superloop.thisTrialN'
p219
I0
sS'superloop.thisTrial'
p220
NsS'superloop.thisN'
p221
I0
sg96
g176
sg24
g25
sS'Train_target_stimuli.thisRepN'
p222
I0
sg18
S'l'
sS'Train_target_stimuli.thisIndex'
p223
g28
(g75
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp224
sg33
g34
sS'Train_target_stimuli.thisN'
p225
I4
sg97
Vl
sg35
V1
sS'superloop.thisIndex'
p226
g83
sg19
I1
sa(dp227
S'superloop.thisRepN'
p228
I0
sS'Train_target_stimuli.thisTrialN'
p229
I5
sg32
g12
sg26
V1
sg20
F0.48131394386291504
sg27
g31
sS'superloop.thisTrialN'
p230
I0
sS'superloop.thisTrial'
p231
NsS'superloop.thisN'
p232
I0
sg96
g176
sg24
g25
sS'Train_target_stimuli.thisRepN'
p233
I0
sg18
S'l'
sS'Train_target_stimuli.thisIndex'
p234
g28
(g75
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp235
sg33
g34
sS'Train_target_stimuli.thisN'
p236
I5
sg97
Vl
sg35
V1
sS'superloop.thisIndex'
p237
g83
sg19
I1
sa(dp238
S'superloop.thisRepN'
p239
I0
sS'Train_target_stimuli.thisTrialN'
p240
I6
sg32
g12
sg26
V1
sg20
F0.38103103637695312
sg27
g31
sS'superloop.thisTrialN'
p241
I0
sS'superloop.thisTrial'
p242
NsS'superloop.thisN'
p243
I0
sg96
g199
sg24
g25
sS'Train_target_stimuli.thisRepN'
p244
I0
sg18
S'l'
sS'Train_target_stimuli.thisIndex'
p245
g28
(g75
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp246
sg33
g34
sS'Train_target_stimuli.thisN'
p247
I6
sg97
Va
sg35
V1
sS'superloop.thisIndex'
p248
g83
sg19
I0
sa(dp249
S'superloop.thisRepN'
p250
I0
sS'Train_target_stimuli.thisTrialN'
p251
I7
sg32
g12
sg26
V1
sg20
F0.29689693450927734
sg27
g31
sS'superloop.thisTrialN'
p252
I0
sS'superloop.thisTrial'
p253
NsS'superloop.thisN'
p254
I0
sg96
g199
sg24
g25
sS'Train_target_stimuli.thisRepN'
p255
I0
sg18
S'a'
sS'Train_target_stimuli.thisIndex'
p256
g28
(g75
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp257
sg33
g34
sS'Train_target_stimuli.thisN'
p258
I7
sg97
Va
sg35
V1
sS'superloop.thisIndex'
p259
g83
sg19
I1
sa(dp260
S'superloop.thisRepN'
p261
I0
sS'Train_target_stimuli.thisTrialN'
p262
I8
sg32
g12
sg26
V1
sg20
F0.5977938175201416
sg27
g31
sS'superloop.thisTrialN'
p263
I0
sS'superloop.thisTrial'
p264
NsS'superloop.thisN'
p265
I0
sg96
g176
sg24
g25
sS'Train_target_stimuli.thisRepN'
p266
I0
sg18
S'a'
sS'Train_target_stimuli.thisIndex'
p267
g28
(g75
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp268
sg33
g34
sS'Train_target_stimuli.thisN'
p269
I8
sg97
Vl
sg35
V1
sS'superloop.thisIndex'
p270
g83
sg19
I0
sa(dp271
S'superloop.thisRepN'
p272
I0
sS'Train_target_stimuli.thisTrialN'
p273
I9
sg32
g12
sg26
V1
sg20
F0.61527109146118164
sg27
g31
sS'superloop.thisTrialN'
p274
I0
sS'superloop.thisTrial'
p275
NsS'superloop.thisN'
p276
I0
sg96
g199
sg24
g25
sS'Train_target_stimuli.thisRepN'
p277
I0
sg18
S'a'
sS'Train_target_stimuli.thisIndex'
p278
g28
(g75
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp279
sg33
g34
sS'Train_target_stimuli.thisN'
p280
I9
sg97
Va
sg35
V1
sS'superloop.thisIndex'
p281
g83
sg19
I1
sasS'loops'
p282
(lp283
g1
(g38
g3
NtRp284
(dp285
g41
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.80.00), juli 10, 2015, at 12:23\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'IAT-1.3'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u'', u'order': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + u'data' + os.path.sep + '%s_%s' %(expInfo['participant'], expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath='C:\u005c\u005cUsers\u005c\u005clsnoek1\u005c\u005cDropbox\u005c\u005cResMas_UvA\u005c\u005cThesis\u005c\u005cGit\u005c\u005cIAT\u005c\u005cexpt\u005c\u005cIAT-1.3.psyexp',\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1680, 1050), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "SetupCode"\u000aSetupCodeClock = core.Clock()\u000a#Order is specified by experimenter at start of experiment via dialogue box\u000aorder=int(expInfo['order']) #convert to integer\u000a\u000a#Now counterbalance pro-stereotype vs anti-stereotype IAT blocks\u000a\u000a#Default is pro-stereotypical - "Congruent" first\u000atrainfiles=['cong_train.xlsx','incong_train.xlsx']\u000atestfiles=['cong_test.xlsx','incong_test.xlsx']\u000atrainlabelsL=['A = \u005cnJanos','A = \u005cnMatthias']\u000atrainlabelsR=['L = \u005cnMatthias','L = \u005cnJanos']\u000atestlabelsL=['A = \u005cnJanos of \u005cnPositief','A = \u005cnMatthias of \u005cnPositief']\u000atestlabelsR=['L = \u005cnMatthias of \u005cnNegatief','L = \u005cnJanos or \u005cnNegatief']\u000a\u000aif order==2:\u000a    #Anti-stereotypical - "Incongruent" first\u000a    trainfiles.reverse()\u000a    testfiles.reverse()\u000a    trainlabelsL.reverse()\u000a    trainlabelsR.reverse()\u000a    testlabelsL.reverse()\u000a    testlabelsR.reverse()\u000a\u000aif order is not (1 or 2):\u000a    print "UNRECOGNISED ORDER CODE - please use 1 or 2 only"\u000a\u000a\u000a#CREDITS\u000a\u000a'''\u000aDeveloped by Robin Scaife on the Leverhulme Trust "Bias and Blame" project 2014\u000aAdditional coding by Tom Stafford with thanks to Lily Fitzgibbon for advice\u000a'''\u000a\u000a# Initialize components for Routine "Instructions"\u000aInstructionsClock = core.Clock()\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text="Je zult woorden plaatjes te zien krijgen die je moet classificeren in categorieen door middel van de 'A' en 'L' toets.\u005cr\u005cn\u005cn\u005crProbeer zo snel mogelijk te kiezen en tegelijkertijd zo weinig mogelijk fouten te maken.\u005cr\u005cn\u005cn\u005crDruk op de spatiebalk om verder te gaan",    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "Keep_in_mind"\u000aKeep_in_mindClock = core.Clock()\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text="Onthoud:\u005cr\u005cn\u005cr\u005cn1) Labels aan de bovenkant van het scherm geven aan welke toets (A/L) hoort bij welke categorie.\u005cr\u005cn\u005cr\u005cn2) Elk woord en elke afbeelding heeft een correcte categorie.\u005cr\u005cn\u005cr\u005cn3) Houd je beide wijsvingers op de 'A' en 'L' toesten om snel antwoord te kunnen geven.\u005cr\u005cn\u005cr\u005cn4) De taak is nutteloos als je te langzaam antwoord geeft; kies daarom zo snel mogelijk\u005cr\u005cn\u005cr\u005cnDruk op de spatiebalk om te beginnen.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "Ready1"\u000aReady1Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text='Bekijk de categorieen bovenaan het scherm.\u005cr\u005cn\u005cr\u005cnPositioneer je wijsvingers op de toetsen (A/L).\u005cr\u005cn\u005cr\u005cnDruk op de spatiebalk om te beginnen.',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='A=Positief',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_5 = visual.TextStim(win=win, ori=0, name='text_5',\u000a    text='L=Negatief',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "Training1"\u000aTraining1Clock = core.Clock()\u000aPositive_label = visual.TextStim(win=win, ori=0, name='Positive_label',\u000a    text='A=Positief',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000aNegative_label = visual.TextStim(win=win, ori=0, name='Negative_label',\u000a    text='L=Negatief',    font='Arial',\u000a    pos=[0.8,0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-2.0)\u000a\u000a# Initialize components for Routine "Feedback1"\u000aFeedback1Clock = core.Clock()\u000amsg=""\u000a\u000atext_27 = visual.TextStim(win=win, ori=0, name='text_27',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_29 = visual.TextStim(win=win, ori=0, name='text_29',\u000a    text='A=Positief',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_30 = visual.TextStim(win=win, ori=0, name='text_30',\u000a    text='L=Negatief',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "Superloop_code"\u000aSuperloop_codeClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "Ready2"\u000aReady2Clock = core.Clock()\u000atext_6 = visual.TextStim(win=win, ori=0, name='text_6',\u000a    text='Bekijk de categorieen bovenaan het scherm.\u005cr\u005cn\u005cr\u005cnPositioneer je wijsvingers op de toetsen (A/L).\u005cr\u005cn\u005cr\u005cnDruk op de spatiebalk om te beginnen.',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_8 = visual.TextStim(win=win, ori=0, name='text_8',\u000a    text='default text',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "Training2"\u000aTraining2Clock = core.Clock()\u000atext_9 = visual.TextStim(win=win, ori=0, name='text_9',\u000a    text='default text',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_10 = visual.TextStim(win=win, ori=0, name='text_10',\u000a    text='default text',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-2.0)\u000a\u000a# Initialize components for Routine "Feedback2"\u000aFeedback2Clock = core.Clock()\u000amsg=""\u000a\u000atext_28 = visual.TextStim(win=win, ori=0, name='text_28',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_31 = visual.TextStim(win=win, ori=0, name='text_31',\u000a    text='default text',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_32 = visual.TextStim(win=win, ori=0, name='text_32',\u000a    text='default text',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "Ready3"\u000aReady3Clock = core.Clock()\u000atext_11 = visual.TextStim(win=win, ori=0, name='text_11',\u000a    text='Bekijk de categorieen bovenaan het scherm.\u005cr\u005cn\u005cr\u005cnPositioneer je wijsvingers op de toetsen (A/L).\u005cr\u005cn\u005cr\u005cnDruk op de spatiebalk om te beginnen.',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_12 = visual.TextStim(win=win, ori=0, name='text_12',\u000a    text='default text',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_13 = visual.TextStim(win=win, ori=0, name='text_13',\u000a    text='default text',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "Non_congruent"\u000aNon_congruentClock = core.Clock()\u000atext_14 = visual.TextStim(win=win, ori=0, name='text_14',\u000a    text='default text',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_15 = visual.TextStim(win=win, ori=0, name='text_15',\u000a    text='default text',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-2.0)\u000a\u000a# Initialize components for Routine "Feedback3"\u000aFeedback3Clock = core.Clock()\u000amsg=""\u000atext_33 = visual.TextStim(win=win, ori=0, name='text_33',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_34 = visual.TextStim(win=win, ori=0, name='text_34',\u000a    text='default text',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_35 = visual.TextStim(win=win, ori=0, name='text_35',\u000a    text='default text',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "End_Thanks"\u000aEnd_ThanksClock = core.Clock()\u000atext_26 = visual.TextStim(win=win, ori=0, name='text_26',\u000a    text='De taak is nu afgelopen!',    font='Arial',\u000a    pos=[0, 0], height=0.2, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "SetupCode"-------\u000at = 0\u000aSetupCodeClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aSetupCodeComponents = []\u000afor thisComponent in SetupCodeComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "SetupCode"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = SetupCodeClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in SetupCodeComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "SetupCode"-------\u000afor thisComponent in SetupCodeComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "SetupCode" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#------Prepare to start Routine "Instructions"-------\u000at = 0\u000aInstructionsClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aInstructionsComponents = []\u000aInstructionsComponents.append(text_2)\u000aInstructionsComponents.append(key_resp_3)\u000afor thisComponent in InstructionsComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Instructions"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = InstructionsClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_2* updates\u000a    if t >= 0.0 and text_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_2.tStart = t  # underestimates by a little under one frame\u000a        text_2.frameNStart = frameN  # exact frame index\u000a        text_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_3* updates\u000a    if t >= 0.0 and key_resp_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_3.frameNStart = frameN  # exact frame index\u000a        key_resp_3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in InstructionsComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Instructions"-------\u000afor thisComponent in InstructionsComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# the Routine "Instructions" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#------Prepare to start Routine "Keep_in_mind"-------\u000at = 0\u000aKeep_in_mindClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aKeep_in_mindComponents = []\u000aKeep_in_mindComponents.append(text_3)\u000aKeep_in_mindComponents.append(key_resp_4)\u000afor thisComponent in Keep_in_mindComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Keep_in_mind"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Keep_in_mindClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_3* updates\u000a    if t >= 0.0 and text_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_3.tStart = t  # underestimates by a little under one frame\u000a        text_3.frameNStart = frameN  # exact frame index\u000a        text_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_4* updates\u000a    if t >= 0.0 and key_resp_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_4.frameNStart = frameN  # exact frame index\u000a        key_resp_4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Keep_in_mindComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Keep_in_mind"-------\u000afor thisComponent in Keep_in_mindComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# the Routine "Keep_in_mind" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#------Prepare to start Routine "Ready1"-------\u000at = 0\u000aReady1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aReady1Components = []\u000aReady1Components.append(text)\u000aReady1Components.append(key_resp_5)\u000aReady1Components.append(text_4)\u000aReady1Components.append(text_5)\u000afor thisComponent in Ready1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Ready1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Ready1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text* updates\u000a    if t >= 0.0 and text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text.tStart = t  # underestimates by a little under one frame\u000a        text.frameNStart = frameN  # exact frame index\u000a        text.setAutoDraw(True)\u000a    \u000a    # *key_resp_5* updates\u000a    if t >= 0.0 and key_resp_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_5.frameNStart = frameN  # exact frame index\u000a        key_resp_5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # *text_4* updates\u000a    if t >= 0.0 and text_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_4.tStart = t  # underestimates by a little under one frame\u000a        text_4.frameNStart = frameN  # exact frame index\u000a        text_4.setAutoDraw(True)\u000a    \u000a    # *text_5* updates\u000a    if t >= 0.0 and text_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_5.tStart = t  # underestimates by a little under one frame\u000a        text_5.frameNStart = frameN  # exact frame index\u000a        text_5.setAutoDraw(True)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Ready1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Ready1"-------\u000afor thisComponent in Ready1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# the Routine "Ready1" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aTrain_pos_neg = data.TrialHandler(nReps=1, method='random', \u000a    extraInfo=expInfo, originPath='C:\u005c\u005cUsers\u005c\u005clsnoek1\u005c\u005cDropbox\u005c\u005cResMas_UvA\u005c\u005cThesis\u005c\u005cGit\u005c\u005cIAT\u005c\u005cexpt\u005c\u005cIAT-1.3.psyexp',\u000a    trialList=data.importConditions('pos_neg_train.xlsx'),\u000a    seed=None, name='Train_pos_neg')\u000athisExp.addLoop(Train_pos_neg)  # add the loop to the experiment\u000athisTrain_pos_neg = Train_pos_neg.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTrain_pos_neg.rgb)\u000aif thisTrain_pos_neg != None:\u000a    for paramName in thisTrain_pos_neg.keys():\u000a        exec(paramName + '= thisTrain_pos_neg.' + paramName)\u000a\u000afor thisTrain_pos_neg in Train_pos_neg:\u000a    currentLoop = Train_pos_neg\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTrain_pos_neg.rgb)\u000a    if thisTrain_pos_neg != None:\u000a        for paramName in thisTrain_pos_neg.keys():\u000a            exec(paramName + '= thisTrain_pos_neg.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Training1"-------\u000a    t = 0\u000a    Training1Clock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    image_3.setImage(os.path.join('stimuli',StimuliImages))\u000a    key_resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    Training1Components = []\u000a    Training1Components.append(Positive_label)\u000a    Training1Components.append(Negative_label)\u000a    Training1Components.append(image_3)\u000a    Training1Components.append(key_resp_2)\u000a    for thisComponent in Training1Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Training1"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Training1Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *Positive_label* updates\u000a        if t >= 0.0 and Positive_label.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Positive_label.tStart = t  # underestimates by a little under one frame\u000a            Positive_label.frameNStart = frameN  # exact frame index\u000a            Positive_label.setAutoDraw(True)\u000a        \u000a        # *Negative_label* updates\u000a        if t >= 0.0 and Negative_label.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Negative_label.tStart = t  # underestimates by a little under one frame\u000a            Negative_label.frameNStart = frameN  # exact frame index\u000a            Negative_label.setAutoDraw(True)\u000a        \u000a        # *image_3* updates\u000a        if t >= 0.0 and image_3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            image_3.tStart = t  # underestimates by a little under one frame\u000a            image_3.frameNStart = frameN  # exact frame index\u000a            image_3.setAutoDraw(True)\u000a        \u000a        # *key_resp_2* updates\u000a        if t >= 0.0 and key_resp_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_2.tStart = t  # underestimates by a little under one frame\u000a            key_resp_2.frameNStart = frameN  # exact frame index\u000a            key_resp_2.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['a', 'l'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_2.rt = key_resp_2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (key_resp_2.keys == str(CorrAns1)) or (key_resp_2.keys == CorrAns1):\u000a                    key_resp_2.corr = 1\u000a                else:\u000a                    key_resp_2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Training1Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Training1"-------\u000a    for thisComponent in Training1Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_2.keys in ['', [], None]:  # No response was made\u000a       key_resp_2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(CorrAns1).lower() == 'none': key_resp_2.corr = 1  # correct non-response\u000a       else: key_resp_2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for Train_pos_neg (TrialHandler)\u000a    Train_pos_neg.addData('key_resp_2.keys',key_resp_2.keys)\u000a    Train_pos_neg.addData('key_resp_2.corr', key_resp_2.corr)\u000a    if key_resp_2.keys != None:  # we had a response\u000a        Train_pos_neg.addData('key_resp_2.rt', key_resp_2.rt)\u000a    # the Routine "Training1" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    #------Prepare to start Routine "Feedback1"-------\u000a    t = 0\u000a    Feedback1Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if key_resp_2.corr==0:\u000a        msg="Fout!"\u000a    elif key_resp_2.corr==1:\u000a        msg=""\u000a    \u000a    text_27.setText(msg)\u000a    # keep track of which components have finished\u000a    Feedback1Components = []\u000a    Feedback1Components.append(text_27)\u000a    Feedback1Components.append(text_29)\u000a    Feedback1Components.append(text_30)\u000a    for thisComponent in Feedback1Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Feedback1"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = Feedback1Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *text_27* updates\u000a        if t >= 0.0 and text_27.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_27.tStart = t  # underestimates by a little under one frame\u000a            text_27.frameNStart = frameN  # exact frame index\u000a            text_27.setAutoDraw(True)\u000a        if text_27.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_27.setAutoDraw(False)\u000a        \u000a        # *text_29* updates\u000a        if t >= 0.0 and text_29.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_29.tStart = t  # underestimates by a little under one frame\u000a            text_29.frameNStart = frameN  # exact frame index\u000a            text_29.setAutoDraw(True)\u000a        if text_29.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_29.setAutoDraw(False)\u000a        \u000a        # *text_30* updates\u000a        if t >= 0.0 and text_30.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_30.tStart = t  # underestimates by a little under one frame\u000a            text_30.frameNStart = frameN  # exact frame index\u000a            text_30.setAutoDraw(True)\u000a        if text_30.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_30.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Feedback1Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Feedback1"-------\u000a    for thisComponent in Feedback1Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'Train_pos_neg'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000asuperloop = data.TrialHandler(nReps=2, method='sequential', \u000a    extraInfo=expInfo, originPath='C:\u005c\u005cUsers\u005c\u005clsnoek1\u005c\u005cDropbox\u005c\u005cResMas_UvA\u005c\u005cThesis\u005c\u005cGit\u005c\u005cIAT\u005c\u005cexpt\u005c\u005cIAT-1.3.psyexp',\u000a    trialList=[None],\u000a    seed=None, name='superloop')\u000athisExp.addLoop(superloop)  # add the loop to the experiment\u000athisSuperloop = superloop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisSuperloop.rgb)\u000aif thisSuperloop != None:\u000a    for paramName in thisSuperloop.keys():\u000a        exec(paramName + '= thisSuperloop.' + paramName)\u000a\u000afor thisSuperloop in superloop:\u000a    currentLoop = superloop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisSuperloop.rgb)\u000a    if thisSuperloop != None:\u000a        for paramName in thisSuperloop.keys():\u000a            exec(paramName + '= thisSuperloop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Superloop_code"-------\u000a    t = 0\u000a    Superloop_codeClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    #Set stimuli files and labels according to this is the 1st or 2nd time we are here\u000a    testblockfile=testfiles[superloop.thisRepN]\u000a    trainblockfile=trainfiles[superloop.thisRepN]\u000a    trainlabelL=trainlabelsL[superloop.thisRepN]\u000a    trainlabelR=trainlabelsR[superloop.thisRepN]\u000a    testlabelL=testlabelsL[superloop.thisRepN]\u000a    testlabelR=testlabelsR[superloop.thisRepN]\u000a    \u000a    # keep track of which components have finished\u000a    Superloop_codeComponents = []\u000a    for thisComponent in Superloop_codeComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Superloop_code"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Superloop_codeClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Superloop_codeComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Superloop_code"-------\u000a    for thisComponent in Superloop_codeComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Superloop_code" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    #------Prepare to start Routine "Ready2"-------\u000a    t = 0\u000a    Ready2Clock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_6.status = NOT_STARTED\u000a    text_7.setText(trainlabelL)\u000a    text_8.setText(trainlabelR)\u000a    # keep track of which components have finished\u000a    Ready2Components = []\u000a    Ready2Components.append(text_6)\u000a    Ready2Components.append(key_resp_6)\u000a    Ready2Components.append(text_7)\u000a    Ready2Components.append(text_8)\u000a    for thisComponent in Ready2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Ready2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Ready2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_6* updates\u000a        if t >= 0.0 and text_6.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_6.tStart = t  # underestimates by a little under one frame\u000a            text_6.frameNStart = frameN  # exact frame index\u000a            text_6.setAutoDraw(True)\u000a        \u000a        # *key_resp_6* updates\u000a        if t >= 0.0 and key_resp_6.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_6.tStart = t  # underestimates by a little under one frame\u000a            key_resp_6.frameNStart = frameN  # exact frame index\u000a            key_resp_6.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_6.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *text_7* updates\u000a        if t >= 0.0 and text_7.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_7.tStart = t  # underestimates by a little under one frame\u000a            text_7.frameNStart = frameN  # exact frame index\u000a            text_7.setAutoDraw(True)\u000a        \u000a        # *text_8* updates\u000a        if t >= 0.0 and text_8.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_8.tStart = t  # underestimates by a little under one frame\u000a            text_8.frameNStart = frameN  # exact frame index\u000a            text_8.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Ready2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Ready2"-------\u000a    for thisComponent in Ready2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # the Routine "Ready2" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Train_target_stimuli = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath='C:\u005c\u005cUsers\u005c\u005clsnoek1\u005c\u005cDropbox\u005c\u005cResMas_UvA\u005c\u005cThesis\u005c\u005cGit\u005c\u005cIAT\u005c\u005cexpt\u005c\u005cIAT-1.3.psyexp',\u000a        trialList=data.importConditions(trainblockfile),\u000a        seed=None, name='Train_target_stimuli')\u000a    thisExp.addLoop(Train_target_stimuli)  # add the loop to the experiment\u000a    thisTrain_target_stimulu = Train_target_stimuli.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrain_target_stimulu.rgb)\u000a    if thisTrain_target_stimulu != None:\u000a        for paramName in thisTrain_target_stimulu.keys():\u000a            exec(paramName + '= thisTrain_target_stimulu.' + paramName)\u000a    \u000a    for thisTrain_target_stimulu in Train_target_stimuli:\u000a        currentLoop = Train_target_stimuli\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrain_target_stimulu.rgb)\u000a        if thisTrain_target_stimulu != None:\u000a            for paramName in thisTrain_target_stimulu.keys():\u000a                exec(paramName + '= thisTrain_target_stimulu.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Training2"-------\u000a        t = 0\u000a        Training2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        text_9.setText(trainlabelL)\u000a        text_10.setText(trainlabelR)\u000a        image.setImage(os.path.join('stimuli',TrialImages))\u000a        key_resp_7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_7.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        Training2Components = []\u000a        Training2Components.append(text_9)\u000a        Training2Components.append(text_10)\u000a        Training2Components.append(image)\u000a        Training2Components.append(key_resp_7)\u000a        for thisComponent in Training2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Training2"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = Training2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text_9* updates\u000a            if t >= 0.0 and text_9.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_9.tStart = t  # underestimates by a little under one frame\u000a                text_9.frameNStart = frameN  # exact frame index\u000a                text_9.setAutoDraw(True)\u000a            \u000a            # *text_10* updates\u000a            if t >= 0.0 and text_10.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_10.tStart = t  # underestimates by a little under one frame\u000a                text_10.frameNStart = frameN  # exact frame index\u000a                text_10.setAutoDraw(True)\u000a            \u000a            # *image* updates\u000a            if t >= 0.0 and image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                image.tStart = t  # underestimates by a little under one frame\u000a                image.frameNStart = frameN  # exact frame index\u000a                image.setAutoDraw(True)\u000a            \u000a            # *key_resp_7* updates\u000a            if t >= 0.0 and key_resp_7.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_7.tStart = t  # underestimates by a little under one frame\u000a                key_resp_7.frameNStart = frameN  # exact frame index\u000a                key_resp_7.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_7.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if key_resp_7.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['a', 'l'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_7.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_7.rt = key_resp_7.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_7.keys == str(CorrAns)) or (key_resp_7.keys == CorrAns):\u000a                        key_resp_7.corr = 1\u000a                    else:\u000a                        key_resp_7.corr = 0\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in Training2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Training2"-------\u000a        for thisComponent in Training2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_7.keys in ['', [], None]:  # No response was made\u000a           key_resp_7.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrAns).lower() == 'none': key_resp_7.corr = 1  # correct non-response\u000a           else: key_resp_7.corr = 0  # failed to respond (incorrectly)\u000a        # store data for Train_target_stimuli (TrialHandler)\u000a        Train_target_stimuli.addData('key_resp_7.keys',key_resp_7.keys)\u000a        Train_target_stimuli.addData('key_resp_7.corr', key_resp_7.corr)\u000a        if key_resp_7.keys != None:  # we had a response\u000a            Train_target_stimuli.addData('key_resp_7.rt', key_resp_7.rt)\u000a        # the Routine "Training2" was not non-slip safe, so reset the non-slip timer\u000a        routineTimer.reset()\u000a        \u000a        #------Prepare to start Routine "Feedback2"-------\u000a        t = 0\u000a        Feedback2Clock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(1.000000)\u000a        # update component parameters for each repeat\u000a        if key_resp_7.corr==0:\u000a            msg="Fout!"\u000a        elif key_resp_7.corr==1:\u000a            msg=""\u000a        \u000a        text_28.setText(msg)\u000a        text_31.setText(trainlabelL)\u000a        text_32.setText(trainlabelR)\u000a        # keep track of which components have finished\u000a        Feedback2Components = []\u000a        Feedback2Components.append(text_28)\u000a        Feedback2Components.append(text_31)\u000a        Feedback2Components.append(text_32)\u000a        for thisComponent in Feedback2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback2"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = Feedback2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *text_28* updates\u000a            if t >= 0.0 and text_28.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_28.tStart = t  # underestimates by a little under one frame\u000a                text_28.frameNStart = frameN  # exact frame index\u000a                text_28.setAutoDraw(True)\u000a            if text_28.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_28.setAutoDraw(False)\u000a            \u000a            # *text_31* updates\u000a            if t >= 0.0 and text_31.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_31.tStart = t  # underestimates by a little under one frame\u000a                text_31.frameNStart = frameN  # exact frame index\u000a                text_31.setAutoDraw(True)\u000a            if text_31.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_31.setAutoDraw(False)\u000a            \u000a            # *text_32* updates\u000a            if t >= 0.0 and text_32.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_32.tStart = t  # underestimates by a little under one frame\u000a                text_32.frameNStart = frameN  # exact frame index\u000a                text_32.setAutoDraw(True)\u000a            if text_32.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_32.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in Feedback2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback2"-------\u000a        for thisComponent in Feedback2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Train_target_stimuli'\u000a    \u000a    \u000a    #------Prepare to start Routine "Ready3"-------\u000a    t = 0\u000a    Ready3Clock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_8.status = NOT_STARTED\u000a    text_12.setText(testlabelL)\u000a    text_13.setText(testlabelR)\u000a    # keep track of which components have finished\u000a    Ready3Components = []\u000a    Ready3Components.append(text_11)\u000a    Ready3Components.append(key_resp_8)\u000a    Ready3Components.append(text_12)\u000a    Ready3Components.append(text_13)\u000a    for thisComponent in Ready3Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Ready3"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Ready3Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_11* updates\u000a        if t >= 0.0 and text_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_11.tStart = t  # underestimates by a little under one frame\u000a            text_11.frameNStart = frameN  # exact frame index\u000a            text_11.setAutoDraw(True)\u000a        \u000a        # *key_resp_8* updates\u000a        if t >= 0.0 and key_resp_8.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_8.tStart = t  # underestimates by a little under one frame\u000a            key_resp_8.frameNStart = frameN  # exact frame index\u000a            key_resp_8.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_8.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *text_12* updates\u000a        if t >= 0.0 and text_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_12.tStart = t  # underestimates by a little under one frame\u000a            text_12.frameNStart = frameN  # exact frame index\u000a            text_12.setAutoDraw(True)\u000a        \u000a        # *text_13* updates\u000a        if t >= 0.0 and text_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_13.tStart = t  # underestimates by a little under one frame\u000a            text_13.frameNStart = frameN  # exact frame index\u000a            text_13.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Ready3Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Ready3"-------\u000a    for thisComponent in Ready3Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # the Routine "Ready3" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Test_associations = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath='C:\u005c\u005cUsers\u005c\u005clsnoek1\u005c\u005cDropbox\u005c\u005cResMas_UvA\u005c\u005cThesis\u005c\u005cGit\u005c\u005cIAT\u005c\u005cexpt\u005c\u005cIAT-1.3.psyexp',\u000a        trialList=data.importConditions(testblockfile),\u000a        seed=None, name='Test_associations')\u000a    thisExp.addLoop(Test_associations)  # add the loop to the experiment\u000a    thisTest_association = Test_associations.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTest_association.rgb)\u000a    if thisTest_association != None:\u000a        for paramName in thisTest_association.keys():\u000a            exec(paramName + '= thisTest_association.' + paramName)\u000a    \u000a    for thisTest_association in Test_associations:\u000a        currentLoop = Test_associations\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTest_association.rgb)\u000a        if thisTest_association != None:\u000a            for paramName in thisTest_association.keys():\u000a                exec(paramName + '= thisTest_association.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Non_congruent"-------\u000a        t = 0\u000a        Non_congruentClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        text_14.setText(testlabelL)\u000a        text_15.setText(testlabelR)\u000a        image_2.setImage(os.path.join('stimuli',TrialImages))\u000a        key_resp_9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_9.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        Non_congruentComponents = []\u000a        Non_congruentComponents.append(text_14)\u000a        Non_congruentComponents.append(text_15)\u000a        Non_congruentComponents.append(image_2)\u000a        Non_congruentComponents.append(key_resp_9)\u000a        for thisComponent in Non_congruentComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Non_congruent"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = Non_congruentClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text_14* updates\u000a            if t >= 0.0 and text_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_14.tStart = t  # underestimates by a little under one frame\u000a                text_14.frameNStart = frameN  # exact frame index\u000a                text_14.setAutoDraw(True)\u000a            \u000a            # *text_15* updates\u000a            if t >= 0.0 and text_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_15.tStart = t  # underestimates by a little under one frame\u000a                text_15.frameNStart = frameN  # exact frame index\u000a                text_15.setAutoDraw(True)\u000a            \u000a            # *image_2* updates\u000a            if t >= 0.0 and image_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                image_2.tStart = t  # underestimates by a little under one frame\u000a                image_2.frameNStart = frameN  # exact frame index\u000a                image_2.setAutoDraw(True)\u000a            \u000a            # *key_resp_9* updates\u000a            if t >= 0.0 and key_resp_9.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_9.tStart = t  # underestimates by a little under one frame\u000a                key_resp_9.frameNStart = frameN  # exact frame index\u000a                key_resp_9.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_9.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if key_resp_9.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['a', 'l'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_9.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_9.rt = key_resp_9.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_9.keys == str(CorrAns)) or (key_resp_9.keys == CorrAns):\u000a                        key_resp_9.corr = 1\u000a                    else:\u000a                        key_resp_9.corr = 0\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in Non_congruentComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Non_congruent"-------\u000a        for thisComponent in Non_congruentComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_9.keys in ['', [], None]:  # No response was made\u000a           key_resp_9.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrAns).lower() == 'none': key_resp_9.corr = 1  # correct non-response\u000a           else: key_resp_9.corr = 0  # failed to respond (incorrectly)\u000a        # store data for Test_associations (TrialHandler)\u000a        Test_associations.addData('key_resp_9.keys',key_resp_9.keys)\u000a        Test_associations.addData('key_resp_9.corr', key_resp_9.corr)\u000a        if key_resp_9.keys != None:  # we had a response\u000a            Test_associations.addData('key_resp_9.rt', key_resp_9.rt)\u000a        # the Routine "Non_congruent" was not non-slip safe, so reset the non-slip timer\u000a        routineTimer.reset()\u000a        \u000a        #------Prepare to start Routine "Feedback3"-------\u000a        t = 0\u000a        Feedback3Clock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(1.000000)\u000a        # update component parameters for each repeat\u000a        if key_resp_9.corr==0:\u000a            msg="Fout!"\u000a        elif key_resp_9.corr==1:\u000a            msg=""\u000a        \u000a        text_33.setText(msg)\u000a        text_34.setText(testlabelL)\u000a        text_35.setText(testlabelR)\u000a        # keep track of which components have finished\u000a        Feedback3Components = []\u000a        Feedback3Components.append(text_33)\u000a        Feedback3Components.append(text_34)\u000a        Feedback3Components.append(text_35)\u000a        for thisComponent in Feedback3Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback3"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = Feedback3Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *text_33* updates\u000a            if t >= 0.0 and text_33.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_33.tStart = t  # underestimates by a little under one frame\u000a                text_33.frameNStart = frameN  # exact frame index\u000a                text_33.setAutoDraw(True)\u000a            if text_33.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_33.setAutoDraw(False)\u000a            \u000a            # *text_34* updates\u000a            if t >= 0.0 and text_34.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_34.tStart = t  # underestimates by a little under one frame\u000a                text_34.frameNStart = frameN  # exact frame index\u000a                text_34.setAutoDraw(True)\u000a            if text_34.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_34.setAutoDraw(False)\u000a            \u000a            # *text_35* updates\u000a            if t >= 0.0 and text_35.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_35.tStart = t  # underestimates by a little under one frame\u000a                text_35.frameNStart = frameN  # exact frame index\u000a                text_35.setAutoDraw(True)\u000a            if text_35.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_35.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in Feedback3Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback3"-------\u000a        for thisComponent in Feedback3Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Test_associations'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 2 repeats of 'superloop'\u000a\u000a\u000a#------Prepare to start Routine "End_Thanks"-------\u000at = 0\u000aEnd_ThanksClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a# keep track of which components have finished\u000aEnd_ThanksComponents = []\u000aEnd_ThanksComponents.append(text_26)\u000afor thisComponent in End_ThanksComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "End_Thanks"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = End_ThanksClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_26* updates\u000a    if t >= 0.0 and text_26.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_26.tStart = t  # underestimates by a little under one frame\u000a        text_26.frameNStart = frameN  # exact frame index\u000a        text_26.setAutoDraw(True)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in End_ThanksComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "End_Thanks"-------\u000afor thisComponent in End_ThanksComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# the Routine "End_Thanks" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000awin.close()\u000acore.quit()\u000a
p286
sg43
(lp287
sg44
I140639271777552
sg11
S'Train_pos_neg'
p288
sg6
g46
sg47
I1
sg21
I01
sg22
g23
sg48
g1
(g49
g50
(dp289
g52
g53
(g54
g55
g56
S'b'
tRp290
(I1
(I10
I1
tg58
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg16
g53
(g54
g55
g56
S'b'
tRp291
(I1
(I10
I1
tg58
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg17
g53
(g54
g55
g56
S'b'
tRp292
(I1
(I10
I1
tg58
I00
S'l\xf3??\x08\xdc??h~\x19?X\x0f\xf7>(u^?\xec\xdd\x9b?\xa0\x14\x15?<]f?\xfcv\x86?h\xec\xad?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg59
g53
(g54
g55
g56
S'b'
tRp293
(I1
(I10
I1
tg58
I00
S'\x00\x00\x00A\x00\x00\x00@\x00\x00\x80@\x00\x00\xc0@\x00\x00\xe0@\x00\x00\x80?\x00\x00@@\x00\x00\x10A\x00\x00\xa0@\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg15
g73
(g55
(I0
tS'b'
tRp294
(I1
(I10
I1
tg29
(S'O8'
I0
I1
tRp295
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp296
S'a'
aS'l'
aS'a'
aS'l'
aS'a'
aS'l'
aS'a'
aS'l'
aS'a'
aS'l'
atbstRp297
(dp298
g63
(dp299
g52
I01
sg16
I01
sg17
I01
sg59
I01
sg15
I00
ssg65
g284
sg66
(lp300
g52
ag59
ag15
ag16
ag17
asg68
(lp301
I10
aI1
asbsg70
S'random'
p302
sg72
g73
(g55
(I0
tS'b'
tRp303
(I1
(I10
I1
tg75
I01
S'\t\x00\x00\x00\x00\x00\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00'
tbsg76
I01
sg77
I1
sg78
I-1
sg79
(lp304
g1
(cpsychopy.data
TrialType
p305
g50
(dp306
g94
g158
sg95
Va
stRp307
ag1
(g305
g50
(dp308
g94
g116
sg95
Vl
stRp309
ag1
(g305
g50
(dp310
g94
g130
sg95
Va
stRp311
ag1
(g305
g50
(dp312
g94
g144
sg95
Vl
stRp313
ag1
(g305
g50
(dp314
g94
g151
sg95
Va
stRp315
ag1
(g305
g50
(dp316
g94
g109
sg95
Vl
stRp317
ag1
(g305
g50
(dp318
g94
g123
sg95
Va
stRp319
ag1
(g305
g50
(dp320
g94
g165
sg95
Vl
stRp321
ag1
(g305
g50
(dp322
g94
g137
sg95
Va
stRp323
ag1
(g305
g50
(dp324
g94
g102
sg95
Vl
stRp325
asg81
Nsg82
g168
sg84
I10
sg85
I0
sg86
I10
sg87
I01
sbag39
ag1
(g38
g3
NtRp326
(dp327
g41
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.80.00), juli 10, 2015, at 12:23\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'IAT-1.3'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u'', u'order': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + u'data' + os.path.sep + '%s_%s' %(expInfo['participant'], expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath='C:\u005c\u005cUsers\u005c\u005clsnoek1\u005c\u005cDropbox\u005c\u005cResMas_UvA\u005c\u005cThesis\u005c\u005cGit\u005c\u005cIAT\u005c\u005cexpt\u005c\u005cIAT-1.3.psyexp',\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1680, 1050), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "SetupCode"\u000aSetupCodeClock = core.Clock()\u000a#Order is specified by experimenter at start of experiment via dialogue box\u000aorder=int(expInfo['order']) #convert to integer\u000a\u000a#Now counterbalance pro-stereotype vs anti-stereotype IAT blocks\u000a\u000a#Default is pro-stereotypical - "Congruent" first\u000atrainfiles=['cong_train.xlsx','incong_train.xlsx']\u000atestfiles=['cong_test.xlsx','incong_test.xlsx']\u000atrainlabelsL=['A = \u005cnJanos','A = \u005cnMatthias']\u000atrainlabelsR=['L = \u005cnMatthias','L = \u005cnJanos']\u000atestlabelsL=['A = \u005cnJanos of \u005cnPositief','A = \u005cnMatthias of \u005cnPositief']\u000atestlabelsR=['L = \u005cnMatthias of \u005cnNegatief','L = \u005cnJanos or \u005cnNegatief']\u000a\u000aif order==2:\u000a    #Anti-stereotypical - "Incongruent" first\u000a    trainfiles.reverse()\u000a    testfiles.reverse()\u000a    trainlabelsL.reverse()\u000a    trainlabelsR.reverse()\u000a    testlabelsL.reverse()\u000a    testlabelsR.reverse()\u000a\u000aif order is not (1 or 2):\u000a    print "UNRECOGNISED ORDER CODE - please use 1 or 2 only"\u000a\u000a\u000a#CREDITS\u000a\u000a'''\u000aDeveloped by Robin Scaife on the Leverhulme Trust "Bias and Blame" project 2014\u000aAdditional coding by Tom Stafford with thanks to Lily Fitzgibbon for advice\u000a'''\u000a\u000a# Initialize components for Routine "Instructions"\u000aInstructionsClock = core.Clock()\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text="Je zult woorden plaatjes te zien krijgen die je moet classificeren in categorieen door middel van de 'A' en 'L' toets.\u005cr\u005cn\u005cn\u005crProbeer zo snel mogelijk te kiezen en tegelijkertijd zo weinig mogelijk fouten te maken.\u005cr\u005cn\u005cn\u005crDruk op de spatiebalk om verder te gaan",    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "Keep_in_mind"\u000aKeep_in_mindClock = core.Clock()\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text="Onthoud:\u005cr\u005cn\u005cr\u005cn1) Labels aan de bovenkant van het scherm geven aan welke toets (A/L) hoort bij welke categorie.\u005cr\u005cn\u005cr\u005cn2) Elk woord en elke afbeelding heeft een correcte categorie.\u005cr\u005cn\u005cr\u005cn3) Houd je beide wijsvingers op de 'A' en 'L' toesten om snel antwoord te kunnen geven.\u005cr\u005cn\u005cr\u005cn4) De taak is nutteloos als je te langzaam antwoord geeft; kies daarom zo snel mogelijk\u005cr\u005cn\u005cr\u005cnDruk op de spatiebalk om te beginnen.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "Ready1"\u000aReady1Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text='Bekijk de categorieen bovenaan het scherm.\u005cr\u005cn\u005cr\u005cnPositioneer je wijsvingers op de toetsen (A/L).\u005cr\u005cn\u005cr\u005cnDruk op de spatiebalk om te beginnen.',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='A=Positief',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_5 = visual.TextStim(win=win, ori=0, name='text_5',\u000a    text='L=Negatief',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "Training1"\u000aTraining1Clock = core.Clock()\u000aPositive_label = visual.TextStim(win=win, ori=0, name='Positive_label',\u000a    text='A=Positief',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000aNegative_label = visual.TextStim(win=win, ori=0, name='Negative_label',\u000a    text='L=Negatief',    font='Arial',\u000a    pos=[0.8,0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-2.0)\u000a\u000a# Initialize components for Routine "Feedback1"\u000aFeedback1Clock = core.Clock()\u000amsg=""\u000a\u000atext_27 = visual.TextStim(win=win, ori=0, name='text_27',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_29 = visual.TextStim(win=win, ori=0, name='text_29',\u000a    text='A=Positief',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_30 = visual.TextStim(win=win, ori=0, name='text_30',\u000a    text='L=Negatief',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "Superloop_code"\u000aSuperloop_codeClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "Ready2"\u000aReady2Clock = core.Clock()\u000atext_6 = visual.TextStim(win=win, ori=0, name='text_6',\u000a    text='Bekijk de categorieen bovenaan het scherm.\u005cr\u005cn\u005cr\u005cnPositioneer je wijsvingers op de toetsen (A/L).\u005cr\u005cn\u005cr\u005cnDruk op de spatiebalk om te beginnen.',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_8 = visual.TextStim(win=win, ori=0, name='text_8',\u000a    text='default text',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "Training2"\u000aTraining2Clock = core.Clock()\u000atext_9 = visual.TextStim(win=win, ori=0, name='text_9',\u000a    text='default text',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_10 = visual.TextStim(win=win, ori=0, name='text_10',\u000a    text='default text',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-2.0)\u000a\u000a# Initialize components for Routine "Feedback2"\u000aFeedback2Clock = core.Clock()\u000amsg=""\u000a\u000atext_28 = visual.TextStim(win=win, ori=0, name='text_28',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_31 = visual.TextStim(win=win, ori=0, name='text_31',\u000a    text='default text',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_32 = visual.TextStim(win=win, ori=0, name='text_32',\u000a    text='default text',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "Ready3"\u000aReady3Clock = core.Clock()\u000atext_11 = visual.TextStim(win=win, ori=0, name='text_11',\u000a    text='Bekijk de categorieen bovenaan het scherm.\u005cr\u005cn\u005cr\u005cnPositioneer je wijsvingers op de toetsen (A/L).\u005cr\u005cn\u005cr\u005cnDruk op de spatiebalk om te beginnen.',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_12 = visual.TextStim(win=win, ori=0, name='text_12',\u000a    text='default text',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_13 = visual.TextStim(win=win, ori=0, name='text_13',\u000a    text='default text',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "Non_congruent"\u000aNon_congruentClock = core.Clock()\u000atext_14 = visual.TextStim(win=win, ori=0, name='text_14',\u000a    text='default text',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_15 = visual.TextStim(win=win, ori=0, name='text_15',\u000a    text='default text',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-2.0)\u000a\u000a# Initialize components for Routine "Feedback3"\u000aFeedback3Clock = core.Clock()\u000amsg=""\u000atext_33 = visual.TextStim(win=win, ori=0, name='text_33',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_34 = visual.TextStim(win=win, ori=0, name='text_34',\u000a    text='default text',    font='Arial',\u000a    pos=[-0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_35 = visual.TextStim(win=win, ori=0, name='text_35',\u000a    text='default text',    font='Arial',\u000a    pos=[0.8, 0.8], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "End_Thanks"\u000aEnd_ThanksClock = core.Clock()\u000atext_26 = visual.TextStim(win=win, ori=0, name='text_26',\u000a    text='De taak is nu afgelopen!',    font='Arial',\u000a    pos=[0, 0], height=0.2, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "SetupCode"-------\u000at = 0\u000aSetupCodeClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aSetupCodeComponents = []\u000afor thisComponent in SetupCodeComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "SetupCode"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = SetupCodeClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in SetupCodeComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "SetupCode"-------\u000afor thisComponent in SetupCodeComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "SetupCode" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#------Prepare to start Routine "Instructions"-------\u000at = 0\u000aInstructionsClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aInstructionsComponents = []\u000aInstructionsComponents.append(text_2)\u000aInstructionsComponents.append(key_resp_3)\u000afor thisComponent in InstructionsComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Instructions"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = InstructionsClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_2* updates\u000a    if t >= 0.0 and text_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_2.tStart = t  # underestimates by a little under one frame\u000a        text_2.frameNStart = frameN  # exact frame index\u000a        text_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_3* updates\u000a    if t >= 0.0 and key_resp_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_3.frameNStart = frameN  # exact frame index\u000a        key_resp_3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in InstructionsComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Instructions"-------\u000afor thisComponent in InstructionsComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# the Routine "Instructions" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#------Prepare to start Routine "Keep_in_mind"-------\u000at = 0\u000aKeep_in_mindClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aKeep_in_mindComponents = []\u000aKeep_in_mindComponents.append(text_3)\u000aKeep_in_mindComponents.append(key_resp_4)\u000afor thisComponent in Keep_in_mindComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Keep_in_mind"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Keep_in_mindClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_3* updates\u000a    if t >= 0.0 and text_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_3.tStart = t  # underestimates by a little under one frame\u000a        text_3.frameNStart = frameN  # exact frame index\u000a        text_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_4* updates\u000a    if t >= 0.0 and key_resp_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_4.frameNStart = frameN  # exact frame index\u000a        key_resp_4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Keep_in_mindComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Keep_in_mind"-------\u000afor thisComponent in Keep_in_mindComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# the Routine "Keep_in_mind" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#------Prepare to start Routine "Ready1"-------\u000at = 0\u000aReady1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aReady1Components = []\u000aReady1Components.append(text)\u000aReady1Components.append(key_resp_5)\u000aReady1Components.append(text_4)\u000aReady1Components.append(text_5)\u000afor thisComponent in Ready1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Ready1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Ready1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text* updates\u000a    if t >= 0.0 and text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text.tStart = t  # underestimates by a little under one frame\u000a        text.frameNStart = frameN  # exact frame index\u000a        text.setAutoDraw(True)\u000a    \u000a    # *key_resp_5* updates\u000a    if t >= 0.0 and key_resp_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_5.frameNStart = frameN  # exact frame index\u000a        key_resp_5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # *text_4* updates\u000a    if t >= 0.0 and text_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_4.tStart = t  # underestimates by a little under one frame\u000a        text_4.frameNStart = frameN  # exact frame index\u000a        text_4.setAutoDraw(True)\u000a    \u000a    # *text_5* updates\u000a    if t >= 0.0 and text_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_5.tStart = t  # underestimates by a little under one frame\u000a        text_5.frameNStart = frameN  # exact frame index\u000a        text_5.setAutoDraw(True)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Ready1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Ready1"-------\u000afor thisComponent in Ready1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# the Routine "Ready1" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aTrain_pos_neg = data.TrialHandler(nReps=1, method='random', \u000a    extraInfo=expInfo, originPath='C:\u005c\u005cUsers\u005c\u005clsnoek1\u005c\u005cDropbox\u005c\u005cResMas_UvA\u005c\u005cThesis\u005c\u005cGit\u005c\u005cIAT\u005c\u005cexpt\u005c\u005cIAT-1.3.psyexp',\u000a    trialList=data.importConditions('pos_neg_train.xlsx'),\u000a    seed=None, name='Train_pos_neg')\u000athisExp.addLoop(Train_pos_neg)  # add the loop to the experiment\u000athisTrain_pos_neg = Train_pos_neg.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTrain_pos_neg.rgb)\u000aif thisTrain_pos_neg != None:\u000a    for paramName in thisTrain_pos_neg.keys():\u000a        exec(paramName + '= thisTrain_pos_neg.' + paramName)\u000a\u000afor thisTrain_pos_neg in Train_pos_neg:\u000a    currentLoop = Train_pos_neg\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTrain_pos_neg.rgb)\u000a    if thisTrain_pos_neg != None:\u000a        for paramName in thisTrain_pos_neg.keys():\u000a            exec(paramName + '= thisTrain_pos_neg.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Training1"-------\u000a    t = 0\u000a    Training1Clock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    image_3.setImage(os.path.join('stimuli',StimuliImages))\u000a    key_resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    Training1Components = []\u000a    Training1Components.append(Positive_label)\u000a    Training1Components.append(Negative_label)\u000a    Training1Components.append(image_3)\u000a    Training1Components.append(key_resp_2)\u000a    for thisComponent in Training1Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Training1"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Training1Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *Positive_label* updates\u000a        if t >= 0.0 and Positive_label.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Positive_label.tStart = t  # underestimates by a little under one frame\u000a            Positive_label.frameNStart = frameN  # exact frame index\u000a            Positive_label.setAutoDraw(True)\u000a        \u000a        # *Negative_label* updates\u000a        if t >= 0.0 and Negative_label.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Negative_label.tStart = t  # underestimates by a little under one frame\u000a            Negative_label.frameNStart = frameN  # exact frame index\u000a            Negative_label.setAutoDraw(True)\u000a        \u000a        # *image_3* updates\u000a        if t >= 0.0 and image_3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            image_3.tStart = t  # underestimates by a little under one frame\u000a            image_3.frameNStart = frameN  # exact frame index\u000a            image_3.setAutoDraw(True)\u000a        \u000a        # *key_resp_2* updates\u000a        if t >= 0.0 and key_resp_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_2.tStart = t  # underestimates by a little under one frame\u000a            key_resp_2.frameNStart = frameN  # exact frame index\u000a            key_resp_2.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['a', 'l'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_2.rt = key_resp_2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (key_resp_2.keys == str(CorrAns1)) or (key_resp_2.keys == CorrAns1):\u000a                    key_resp_2.corr = 1\u000a                else:\u000a                    key_resp_2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Training1Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Training1"-------\u000a    for thisComponent in Training1Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_2.keys in ['', [], None]:  # No response was made\u000a       key_resp_2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(CorrAns1).lower() == 'none': key_resp_2.corr = 1  # correct non-response\u000a       else: key_resp_2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for Train_pos_neg (TrialHandler)\u000a    Train_pos_neg.addData('key_resp_2.keys',key_resp_2.keys)\u000a    Train_pos_neg.addData('key_resp_2.corr', key_resp_2.corr)\u000a    if key_resp_2.keys != None:  # we had a response\u000a        Train_pos_neg.addData('key_resp_2.rt', key_resp_2.rt)\u000a    # the Routine "Training1" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    #------Prepare to start Routine "Feedback1"-------\u000a    t = 0\u000a    Feedback1Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if key_resp_2.corr==0:\u000a        msg="Fout!"\u000a    elif key_resp_2.corr==1:\u000a        msg=""\u000a    \u000a    text_27.setText(msg)\u000a    # keep track of which components have finished\u000a    Feedback1Components = []\u000a    Feedback1Components.append(text_27)\u000a    Feedback1Components.append(text_29)\u000a    Feedback1Components.append(text_30)\u000a    for thisComponent in Feedback1Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Feedback1"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = Feedback1Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *text_27* updates\u000a        if t >= 0.0 and text_27.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_27.tStart = t  # underestimates by a little under one frame\u000a            text_27.frameNStart = frameN  # exact frame index\u000a            text_27.setAutoDraw(True)\u000a        if text_27.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_27.setAutoDraw(False)\u000a        \u000a        # *text_29* updates\u000a        if t >= 0.0 and text_29.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_29.tStart = t  # underestimates by a little under one frame\u000a            text_29.frameNStart = frameN  # exact frame index\u000a            text_29.setAutoDraw(True)\u000a        if text_29.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_29.setAutoDraw(False)\u000a        \u000a        # *text_30* updates\u000a        if t >= 0.0 and text_30.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_30.tStart = t  # underestimates by a little under one frame\u000a            text_30.frameNStart = frameN  # exact frame index\u000a            text_30.setAutoDraw(True)\u000a        if text_30.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_30.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Feedback1Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Feedback1"-------\u000a    for thisComponent in Feedback1Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'Train_pos_neg'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000asuperloop = data.TrialHandler(nReps=2, method='sequential', \u000a    extraInfo=expInfo, originPath='C:\u005c\u005cUsers\u005c\u005clsnoek1\u005c\u005cDropbox\u005c\u005cResMas_UvA\u005c\u005cThesis\u005c\u005cGit\u005c\u005cIAT\u005c\u005cexpt\u005c\u005cIAT-1.3.psyexp',\u000a    trialList=[None],\u000a    seed=None, name='superloop')\u000athisExp.addLoop(superloop)  # add the loop to the experiment\u000athisSuperloop = superloop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisSuperloop.rgb)\u000aif thisSuperloop != None:\u000a    for paramName in thisSuperloop.keys():\u000a        exec(paramName + '= thisSuperloop.' + paramName)\u000a\u000afor thisSuperloop in superloop:\u000a    currentLoop = superloop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisSuperloop.rgb)\u000a    if thisSuperloop != None:\u000a        for paramName in thisSuperloop.keys():\u000a            exec(paramName + '= thisSuperloop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Superloop_code"-------\u000a    t = 0\u000a    Superloop_codeClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    #Set stimuli files and labels according to this is the 1st or 2nd time we are here\u000a    testblockfile=testfiles[superloop.thisRepN]\u000a    trainblockfile=trainfiles[superloop.thisRepN]\u000a    trainlabelL=trainlabelsL[superloop.thisRepN]\u000a    trainlabelR=trainlabelsR[superloop.thisRepN]\u000a    testlabelL=testlabelsL[superloop.thisRepN]\u000a    testlabelR=testlabelsR[superloop.thisRepN]\u000a    \u000a    # keep track of which components have finished\u000a    Superloop_codeComponents = []\u000a    for thisComponent in Superloop_codeComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Superloop_code"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Superloop_codeClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Superloop_codeComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Superloop_code"-------\u000a    for thisComponent in Superloop_codeComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Superloop_code" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    #------Prepare to start Routine "Ready2"-------\u000a    t = 0\u000a    Ready2Clock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_6.status = NOT_STARTED\u000a    text_7.setText(trainlabelL)\u000a    text_8.setText(trainlabelR)\u000a    # keep track of which components have finished\u000a    Ready2Components = []\u000a    Ready2Components.append(text_6)\u000a    Ready2Components.append(key_resp_6)\u000a    Ready2Components.append(text_7)\u000a    Ready2Components.append(text_8)\u000a    for thisComponent in Ready2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Ready2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Ready2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_6* updates\u000a        if t >= 0.0 and text_6.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_6.tStart = t  # underestimates by a little under one frame\u000a            text_6.frameNStart = frameN  # exact frame index\u000a            text_6.setAutoDraw(True)\u000a        \u000a        # *key_resp_6* updates\u000a        if t >= 0.0 and key_resp_6.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_6.tStart = t  # underestimates by a little under one frame\u000a            key_resp_6.frameNStart = frameN  # exact frame index\u000a            key_resp_6.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_6.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *text_7* updates\u000a        if t >= 0.0 and text_7.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_7.tStart = t  # underestimates by a little under one frame\u000a            text_7.frameNStart = frameN  # exact frame index\u000a            text_7.setAutoDraw(True)\u000a        \u000a        # *text_8* updates\u000a        if t >= 0.0 and text_8.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_8.tStart = t  # underestimates by a little under one frame\u000a            text_8.frameNStart = frameN  # exact frame index\u000a            text_8.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Ready2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Ready2"-------\u000a    for thisComponent in Ready2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # the Routine "Ready2" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Train_target_stimuli = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath='C:\u005c\u005cUsers\u005c\u005clsnoek1\u005c\u005cDropbox\u005c\u005cResMas_UvA\u005c\u005cThesis\u005c\u005cGit\u005c\u005cIAT\u005c\u005cexpt\u005c\u005cIAT-1.3.psyexp',\u000a        trialList=data.importConditions(trainblockfile),\u000a        seed=None, name='Train_target_stimuli')\u000a    thisExp.addLoop(Train_target_stimuli)  # add the loop to the experiment\u000a    thisTrain_target_stimulu = Train_target_stimuli.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrain_target_stimulu.rgb)\u000a    if thisTrain_target_stimulu != None:\u000a        for paramName in thisTrain_target_stimulu.keys():\u000a            exec(paramName + '= thisTrain_target_stimulu.' + paramName)\u000a    \u000a    for thisTrain_target_stimulu in Train_target_stimuli:\u000a        currentLoop = Train_target_stimuli\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrain_target_stimulu.rgb)\u000a        if thisTrain_target_stimulu != None:\u000a            for paramName in thisTrain_target_stimulu.keys():\u000a                exec(paramName + '= thisTrain_target_stimulu.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Training2"-------\u000a        t = 0\u000a        Training2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        text_9.setText(trainlabelL)\u000a        text_10.setText(trainlabelR)\u000a        image.setImage(os.path.join('stimuli',TrialImages))\u000a        key_resp_7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_7.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        Training2Components = []\u000a        Training2Components.append(text_9)\u000a        Training2Components.append(text_10)\u000a        Training2Components.append(image)\u000a        Training2Components.append(key_resp_7)\u000a        for thisComponent in Training2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Training2"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = Training2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text_9* updates\u000a            if t >= 0.0 and text_9.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_9.tStart = t  # underestimates by a little under one frame\u000a                text_9.frameNStart = frameN  # exact frame index\u000a                text_9.setAutoDraw(True)\u000a            \u000a            # *text_10* updates\u000a            if t >= 0.0 and text_10.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_10.tStart = t  # underestimates by a little under one frame\u000a                text_10.frameNStart = frameN  # exact frame index\u000a                text_10.setAutoDraw(True)\u000a            \u000a            # *image* updates\u000a            if t >= 0.0 and image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                image.tStart = t  # underestimates by a little under one frame\u000a                image.frameNStart = frameN  # exact frame index\u000a                image.setAutoDraw(True)\u000a            \u000a            # *key_resp_7* updates\u000a            if t >= 0.0 and key_resp_7.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_7.tStart = t  # underestimates by a little under one frame\u000a                key_resp_7.frameNStart = frameN  # exact frame index\u000a                key_resp_7.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_7.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if key_resp_7.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['a', 'l'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_7.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_7.rt = key_resp_7.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_7.keys == str(CorrAns)) or (key_resp_7.keys == CorrAns):\u000a                        key_resp_7.corr = 1\u000a                    else:\u000a                        key_resp_7.corr = 0\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in Training2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Training2"-------\u000a        for thisComponent in Training2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_7.keys in ['', [], None]:  # No response was made\u000a           key_resp_7.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrAns).lower() == 'none': key_resp_7.corr = 1  # correct non-response\u000a           else: key_resp_7.corr = 0  # failed to respond (incorrectly)\u000a        # store data for Train_target_stimuli (TrialHandler)\u000a        Train_target_stimuli.addData('key_resp_7.keys',key_resp_7.keys)\u000a        Train_target_stimuli.addData('key_resp_7.corr', key_resp_7.corr)\u000a        if key_resp_7.keys != None:  # we had a response\u000a            Train_target_stimuli.addData('key_resp_7.rt', key_resp_7.rt)\u000a        # the Routine "Training2" was not non-slip safe, so reset the non-slip timer\u000a        routineTimer.reset()\u000a        \u000a        #------Prepare to start Routine "Feedback2"-------\u000a        t = 0\u000a        Feedback2Clock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(1.000000)\u000a        # update component parameters for each repeat\u000a        if key_resp_7.corr==0:\u000a            msg="Fout!"\u000a        elif key_resp_7.corr==1:\u000a            msg=""\u000a        \u000a        text_28.setText(msg)\u000a        text_31.setText(trainlabelL)\u000a        text_32.setText(trainlabelR)\u000a        # keep track of which components have finished\u000a        Feedback2Components = []\u000a        Feedback2Components.append(text_28)\u000a        Feedback2Components.append(text_31)\u000a        Feedback2Components.append(text_32)\u000a        for thisComponent in Feedback2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback2"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = Feedback2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *text_28* updates\u000a            if t >= 0.0 and text_28.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_28.tStart = t  # underestimates by a little under one frame\u000a                text_28.frameNStart = frameN  # exact frame index\u000a                text_28.setAutoDraw(True)\u000a            if text_28.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_28.setAutoDraw(False)\u000a            \u000a            # *text_31* updates\u000a            if t >= 0.0 and text_31.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_31.tStart = t  # underestimates by a little under one frame\u000a                text_31.frameNStart = frameN  # exact frame index\u000a                text_31.setAutoDraw(True)\u000a            if text_31.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_31.setAutoDraw(False)\u000a            \u000a            # *text_32* updates\u000a            if t >= 0.0 and text_32.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_32.tStart = t  # underestimates by a little under one frame\u000a                text_32.frameNStart = frameN  # exact frame index\u000a                text_32.setAutoDraw(True)\u000a            if text_32.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_32.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in Feedback2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback2"-------\u000a        for thisComponent in Feedback2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Train_target_stimuli'\u000a    \u000a    \u000a    #------Prepare to start Routine "Ready3"-------\u000a    t = 0\u000a    Ready3Clock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_8.status = NOT_STARTED\u000a    text_12.setText(testlabelL)\u000a    text_13.setText(testlabelR)\u000a    # keep track of which components have finished\u000a    Ready3Components = []\u000a    Ready3Components.append(text_11)\u000a    Ready3Components.append(key_resp_8)\u000a    Ready3Components.append(text_12)\u000a    Ready3Components.append(text_13)\u000a    for thisComponent in Ready3Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Ready3"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Ready3Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_11* updates\u000a        if t >= 0.0 and text_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_11.tStart = t  # underestimates by a little under one frame\u000a            text_11.frameNStart = frameN  # exact frame index\u000a            text_11.setAutoDraw(True)\u000a        \u000a        # *key_resp_8* updates\u000a        if t >= 0.0 and key_resp_8.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_8.tStart = t  # underestimates by a little under one frame\u000a            key_resp_8.frameNStart = frameN  # exact frame index\u000a            key_resp_8.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_8.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *text_12* updates\u000a        if t >= 0.0 and text_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_12.tStart = t  # underestimates by a little under one frame\u000a            text_12.frameNStart = frameN  # exact frame index\u000a            text_12.setAutoDraw(True)\u000a        \u000a        # *text_13* updates\u000a        if t >= 0.0 and text_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_13.tStart = t  # underestimates by a little under one frame\u000a            text_13.frameNStart = frameN  # exact frame index\u000a            text_13.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Ready3Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Ready3"-------\u000a    for thisComponent in Ready3Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # the Routine "Ready3" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Test_associations = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath='C:\u005c\u005cUsers\u005c\u005clsnoek1\u005c\u005cDropbox\u005c\u005cResMas_UvA\u005c\u005cThesis\u005c\u005cGit\u005c\u005cIAT\u005c\u005cexpt\u005c\u005cIAT-1.3.psyexp',\u000a        trialList=data.importConditions(testblockfile),\u000a        seed=None, name='Test_associations')\u000a    thisExp.addLoop(Test_associations)  # add the loop to the experiment\u000a    thisTest_association = Test_associations.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTest_association.rgb)\u000a    if thisTest_association != None:\u000a        for paramName in thisTest_association.keys():\u000a            exec(paramName + '= thisTest_association.' + paramName)\u000a    \u000a    for thisTest_association in Test_associations:\u000a        currentLoop = Test_associations\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTest_association.rgb)\u000a        if thisTest_association != None:\u000a            for paramName in thisTest_association.keys():\u000a                exec(paramName + '= thisTest_association.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Non_congruent"-------\u000a        t = 0\u000a        Non_congruentClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        text_14.setText(testlabelL)\u000a        text_15.setText(testlabelR)\u000a        image_2.setImage(os.path.join('stimuli',TrialImages))\u000a        key_resp_9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_9.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        Non_congruentComponents = []\u000a        Non_congruentComponents.append(text_14)\u000a        Non_congruentComponents.append(text_15)\u000a        Non_congruentComponents.append(image_2)\u000a        Non_congruentComponents.append(key_resp_9)\u000a        for thisComponent in Non_congruentComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Non_congruent"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = Non_congruentClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text_14* updates\u000a            if t >= 0.0 and text_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_14.tStart = t  # underestimates by a little under one frame\u000a                text_14.frameNStart = frameN  # exact frame index\u000a                text_14.setAutoDraw(True)\u000a            \u000a            # *text_15* updates\u000a            if t >= 0.0 and text_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_15.tStart = t  # underestimates by a little under one frame\u000a                text_15.frameNStart = frameN  # exact frame index\u000a                text_15.setAutoDraw(True)\u000a            \u000a            # *image_2* updates\u000a            if t >= 0.0 and image_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                image_2.tStart = t  # underestimates by a little under one frame\u000a                image_2.frameNStart = frameN  # exact frame index\u000a                image_2.setAutoDraw(True)\u000a            \u000a            # *key_resp_9* updates\u000a            if t >= 0.0 and key_resp_9.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_9.tStart = t  # underestimates by a little under one frame\u000a                key_resp_9.frameNStart = frameN  # exact frame index\u000a                key_resp_9.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_9.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if key_resp_9.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['a', 'l'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_9.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_9.rt = key_resp_9.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_9.keys == str(CorrAns)) or (key_resp_9.keys == CorrAns):\u000a                        key_resp_9.corr = 1\u000a                    else:\u000a                        key_resp_9.corr = 0\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in Non_congruentComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Non_congruent"-------\u000a        for thisComponent in Non_congruentComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_9.keys in ['', [], None]:  # No response was made\u000a           key_resp_9.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrAns).lower() == 'none': key_resp_9.corr = 1  # correct non-response\u000a           else: key_resp_9.corr = 0  # failed to respond (incorrectly)\u000a        # store data for Test_associations (TrialHandler)\u000a        Test_associations.addData('key_resp_9.keys',key_resp_9.keys)\u000a        Test_associations.addData('key_resp_9.corr', key_resp_9.corr)\u000a        if key_resp_9.keys != None:  # we had a response\u000a            Test_associations.addData('key_resp_9.rt', key_resp_9.rt)\u000a        # the Routine "Non_congruent" was not non-slip safe, so reset the non-slip timer\u000a        routineTimer.reset()\u000a        \u000a        #------Prepare to start Routine "Feedback3"-------\u000a        t = 0\u000a        Feedback3Clock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(1.000000)\u000a        # update component parameters for each repeat\u000a        if key_resp_9.corr==0:\u000a            msg="Fout!"\u000a        elif key_resp_9.corr==1:\u000a            msg=""\u000a        \u000a        text_33.setText(msg)\u000a        text_34.setText(testlabelL)\u000a        text_35.setText(testlabelR)\u000a        # keep track of which components have finished\u000a        Feedback3Components = []\u000a        Feedback3Components.append(text_33)\u000a        Feedback3Components.append(text_34)\u000a        Feedback3Components.append(text_35)\u000a        for thisComponent in Feedback3Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback3"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = Feedback3Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *text_33* updates\u000a            if t >= 0.0 and text_33.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_33.tStart = t  # underestimates by a little under one frame\u000a                text_33.frameNStart = frameN  # exact frame index\u000a                text_33.setAutoDraw(True)\u000a            if text_33.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_33.setAutoDraw(False)\u000a            \u000a            # *text_34* updates\u000a            if t >= 0.0 and text_34.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_34.tStart = t  # underestimates by a little under one frame\u000a                text_34.frameNStart = frameN  # exact frame index\u000a                text_34.setAutoDraw(True)\u000a            if text_34.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_34.setAutoDraw(False)\u000a            \u000a            # *text_35* updates\u000a            if t >= 0.0 and text_35.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_35.tStart = t  # underestimates by a little under one frame\u000a                text_35.frameNStart = frameN  # exact frame index\u000a                text_35.setAutoDraw(True)\u000a            if text_35.status == STARTED and t >= (0.0 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_35.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in Feedback3Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback3"-------\u000a        for thisComponent in Feedback3Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Test_associations'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 2 repeats of 'superloop'\u000a\u000a\u000a#------Prepare to start Routine "End_Thanks"-------\u000at = 0\u000aEnd_ThanksClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a# keep track of which components have finished\u000aEnd_ThanksComponents = []\u000aEnd_ThanksComponents.append(text_26)\u000afor thisComponent in End_ThanksComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "End_Thanks"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = End_ThanksClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_26* updates\u000a    if t >= 0.0 and text_26.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_26.tStart = t  # underestimates by a little under one frame\u000a        text_26.frameNStart = frameN  # exact frame index\u000a        text_26.setAutoDraw(True)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in End_ThanksComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "End_Thanks"-------\u000afor thisComponent in End_ThanksComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# the Routine "End_Thanks" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000awin.close()\u000acore.quit()\u000a
p328
sg43
(lp329
sg44
I140639271777552
sg11
S'Train_target_stimuli'
p330
sg6
g46
sg47
I1
sg21
I01
sg22
g23
sg48
g1
(g49
g50
(dp331
g52
g53
(g54
g55
g56
S'b'
tRp332
(I1
(I10
I1
tg58
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g53
(g54
g55
g56
S'b'
tRp333
(I1
(I10
I1
tg58
I00
S'\xc8n\xf6>\x84\xb42?\x04\t\x19?\x80\x16\xc3>\x0e\x13\x89?\x02>\x95?\xccJ;?\xe0\x02\x98>8\xc3\x14?h\x82\x1d?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg18
g73
(g55
(I0
tS'b'
tRp334
(I1
(I10
I1
tg295
I00
(lp335
S'l'
aS'a'
aS'a'
aS'l'
aS'l'
aS'a'
aS'l'
aS'a'
aS'l'
aS'a'
atbsg59
g53
(g54
g55
g56
S'b'
tRp336
(I1
(I10
I1
tg58
I00
S'\x00\x00\xa0@\x00\x00\x00@\x00\x00\x00A\x00\x00\xc0@\x00\x00\x00\x00\x00\x00@@\x00\x00\x80@\x00\x00\xe0@\x00\x00\x80?\x00\x00\x10A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g53
(g54
g55
g56
S'b'
tRp337
(I1
(I10
I1
tg58
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp338
(dp339
g63
(dp340
g52
I01
sg20
I01
sg19
I01
sg59
I01
sg18
I00
ssg65
g326
sg66
(lp341
g52
ag59
ag18
ag19
ag20
asg68
(lp342
I10
aI1
asbsg70
g302
sg72
g73
(g55
(I0
tS'b'
tRp343
(I1
(I10
I1
tg75
I01
S'\x04\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\t\x00\x00\x00\x00\x00\x00\x00'
tbsg76
I01
sg77
I1
sg78
I-1
sg79
(lp344
g1
(g305
g50
(dp345
g96
g176
sg97
Vl
stRp346
ag1
(g305
g50
(dp347
g96
g199
sg97
Va
stRp348
ag1
(g305
g50
(dp349
g96
g176
sg97
Vl
stRp350
ag1
(g305
g50
(dp351
g96
g199
sg97
Va
stRp352
ag1
(g305
g50
(dp353
g96
g176
sg97
Vl
stRp354
ag1
(g305
g50
(dp355
g96
g199
sg97
Va
stRp356
ag1
(g305
g50
(dp357
g96
g176
sg97
Vl
stRp358
ag1
(g305
g50
(dp359
g96
g199
sg97
Va
stRp360
ag1
(g305
g50
(dp361
g96
g176
sg97
Vl
stRp362
ag1
(g305
g50
(dp363
g96
g199
sg97
Va
stRp364
asg81
Nsg82
g279
sg84
I10
sg85
I0
sg86
I10
sg87
I01
sbasS'savePickle'
p365
I00
sb.